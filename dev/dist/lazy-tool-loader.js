#!/usr/bin/env node
import*as r from"node:path";import*as c from"node:fs/promises";import{createHash as m}from"node:crypto";var u=class s{static instance;metadataCache=new Map;loadedModules=new Map;stats={totalToolsDiscovered:0,totalToolsLoaded:0,totalToolsCached:0,cacheHits:0,cacheMisses:0,lastDiscovery:new Date,lastLoad:new Date};constructor(){}static getInstance(){return s.instance||(s.instance=new s),s.instance}async discoverTools(t="dev/src/tools"){let o=[];try{let e=r.resolve(t);await this.scanDirectory(e,o),this.stats.totalToolsDiscovered=o.length,this.stats.lastDiscovery=new Date;for(let a of o)this.metadataCache.set(a.name,a);this.stats.totalToolsCached=this.metadataCache.size,process.env.LOG_LAZY_LOADER==="1"&&console.log(`\u{1F50D} [LazyLoader] Discovered ${o.length} tools`)}catch(e){console.error("\u274C [LazyLoader] Discovery failed:",e)}return o}getToolMetadata(t){return this.metadataCache.get(t)}hasTool(t){return this.metadataCache.has(t)}listDiscoveredTools(){return Array.from(this.metadataCache.values())}async loadTool(t){let o=this.metadataCache.get(t);if(!o)throw new Error(`Tool '${t}' not found in metadata cache. Run discovery first.`);if(this.loadedModules.has(t))return this.stats.cacheHits++,process.env.LOG_LAZY_LOADER==="1"&&console.log(`\u{1F3AF} [LazyLoader] Cache hit for tool: ${t}`),this.loadedModules.get(t);this.stats.cacheMisses++;try{let a=await import(r.resolve(o.sourceFile)),i=a[o.registerFunction];if(!i)throw new Error(`Register function '${o.registerFunction}' not found in ${o.sourceFile}`);return this.loadedModules.set(t,{module:a,registerFunction:i,metadata:o}),this.stats.totalToolsLoaded++,this.stats.lastLoad=new Date,process.env.LOG_LAZY_LOADER==="1"&&console.log(`\u26A1 [LazyLoader] Loaded tool: ${t} from ${o.sourceFile}`),this.loadedModules.get(t)}catch(e){throw console.error(`\u274C [LazyLoader] Failed to load tool '${t}':`,e),e}}async registerTool(t,o){try{let e=await this.loadTool(o),{registerFunction:a,metadata:i}=e;return await a(t),process.env.LOG_LAZY_LOADER==="1"&&console.log(`\u2705 [LazyLoader] Registered tool: ${o}`),!0}catch(e){return console.error(`\u274C [LazyLoader] Failed to register tool '${o}':`,e),!1}}async preloadTools(t){let o=t.map(async e=>{try{await this.loadTool(e)}catch(a){console.warn(`\u26A0\uFE0F [LazyLoader] Failed to preload tool '${e}':`,a)}});await Promise.all(o),process.env.LOG_LAZY_LOADER==="1"&&console.log(`\u{1F680} [LazyLoader] Preloaded ${t.length} tools`)}getStats(){return{...this.stats}}clearCache(){this.metadataCache.clear(),this.loadedModules.clear(),this.stats={totalToolsDiscovered:0,totalToolsLoaded:0,totalToolsCached:0,cacheHits:0,cacheMisses:0,lastDiscovery:new Date,lastLoad:new Date}}async scanDirectory(t,o){try{let e=await c.readdir(t,{withFileTypes:!0});for(let a of e){let i=r.join(t,a.name);if(a.isDirectory())await this.scanDirectory(i,o);else if(a.isFile()&&this.isToolFile(a.name)){let l=await this.analyzeToolFile(i);l&&o.push(l)}}}catch(e){console.warn(`\u26A0\uFE0F [LazyLoader] Failed to scan directory '${t}':`,e)}}isToolFile(t){return t.endsWith(".ts")||t.endsWith(".js")}async analyzeToolFile(t){try{let o=await c.readFile(t,"utf-8"),e=await c.stat(t),a=r.basename(t,r.extname(t)),i=o.match(/export\s+function\s+(register\w+)\s*\(/);if(!i)return null;let l=i[1],h=o.match(/description:\s*["'`]([^"'`]+)["'`]/),y=h?h[1]:`Tool from ${a}`,p=o.match(/inputSchema:\s*(\{[^}]*\})/s),d={};if(p)try{d={extracted:!0}}catch{d={}}let g=m("sha256").update(o).digest("hex").substring(0,16),L=this.determineCategory(t);return{name:`mcp_mcp-god-mode_${a}`,description:y,inputSchema:d,sourceFile:t,registerFunction:l,category:L,lastModified:e.mtime,fileSize:e.size,signature:g}}catch(o){return console.warn(`\u26A0\uFE0F [LazyLoader] Failed to analyze file '${t}':`,o),null}}determineCategory(t){let o=t.split(r.sep),e=o.indexOf("tools");return e>=0&&o[e+1]?o[e+1]:"unknown"}},n=u.getInstance();async function z(s){return n.discoverTools(s)}function M(s){return n.getToolMetadata(s)}function w(s){return n.hasTool(s)}async function D(s){return n.loadTool(s)}async function b(s,t){return n.registerTool(s,t)}async function F(s){return n.preloadTools(s)}function x(){return n.getStats()}export{u as LazyToolLoader,z as discoverAllTools,x as getLoaderStats,M as getToolMetadata,w as hasTool,n as lazyLoader,D as loadTool,F as preloadTools,b as registerTool};
