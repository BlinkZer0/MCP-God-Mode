import { z } from "zod";
export function registerPenTestPlusPlusNaturalLanguage(server) {
    server.registerTool("pentest_plus_plus_natural_language", {
        description: "ðŸ¤– **PenTest++ Natural Language Interface** - Process natural language commands for PenTest++ AI-augmented penetration testing operations. Converts conversational requests like 'perform reconnaissance on the target' into structured PenTest++ commands.",
        inputSchema: {
            command: z.string().describe("Natural language command for PenTest++ operations (e.g., 'perform reconnaissance on the target', 'generate AI workflow for penetration testing', 'integrate with Metasploit', 'predict attack paths for the system')")
        },
        outputSchema: {
            success: z.boolean(),
            message: z.string(),
            parsed_command: z.object({
                action: z.string(),
                target: z.string(),
                target_type: z.string().optional(),
                reconnaissance_type: z.string().optional(),
                vulnerability_type: z.string().optional(),
                exploit_framework: z.string().optional(),
                attack_vector: z.string().optional(),
                payload_type: z.string().optional(),
                report_format: z.string().optional(),
                ai_model: z.string().optional(),
                automation_level: z.string().optional(),
                stealth_mode: z.boolean().optional(),
                ai_workflow_generation: z.boolean().optional(),
                attack_path_prediction: z.boolean().optional(),
                integration_type: z.string().optional(),
                ethical_guidelines: z.boolean().optional(),
                safe_mode: z.boolean().optional()
            })
        }
    }, async ({ command }) => {
        try {
            const parsed = processNaturalLanguageCommand(command);
            return {
                success: true,
                message: `PenTest++ natural language command processed: ${command}`,
                parsed_command: parsed
            };
        }
        catch (error) {
            return {
                success: false,
                message: `Failed to process natural language command: ${error instanceof Error ? error.message : String(error)}`,
                parsed_command: {
                    action: "reconnaissance",
                    target: "",
                    safe_mode: true
                }
            };
        }
    });
}
function processNaturalLanguageCommand(command) {
    const lowerCommand = command.toLowerCase();
    // Extract target from command
    const targetMatch = command.match(/(?:on|for|against|target|test|scan|analyze)\s+([a-zA-Z0-9\-_\.\/\s]+?)(?:\s+(?:with|using|for|in|on)|$)/i);
    const target = targetMatch ? targetMatch[1].trim() : "target_system";
    // Determine action based on keywords
    let action = "reconnaissance";
    let target_type = "web_application";
    let reconnaissance_type = "comprehensive";
    let vulnerability_type = "all";
    let exploit_framework = "metasploit";
    let attack_vector = "web_application";
    let payload_type = "reverse_shell";
    let report_format = "pdf";
    let ai_model = "gpt-4";
    let automation_level = "semi_automated";
    let stealth_mode = false;
    let ai_workflow_generation = false;
    let attack_path_prediction = false;
    let integration_type = "metasploit";
    let ethical_guidelines = true;
    let safe_mode = false;
    // Action detection
    if (lowerCommand.includes("reconnaissance") || lowerCommand.includes("recon") || lowerCommand.includes("scan") || lowerCommand.includes("discover")) {
        action = "reconnaissance";
    }
    else if (lowerCommand.includes("vulnerability") || lowerCommand.includes("vuln") || lowerCommand.includes("find vulnerabilities")) {
        action = "vulnerability_discovery";
    }
    else if (lowerCommand.includes("exploit") || lowerCommand.includes("develop exploit") || lowerCommand.includes("create exploit")) {
        action = "exploit_development";
    }
    else if (lowerCommand.includes("ai workflow") || lowerCommand.includes("generate workflow") || lowerCommand.includes("automate")) {
        action = "ai_workflow_generation";
    }
    else if (lowerCommand.includes("predict") || lowerCommand.includes("attack path") || lowerCommand.includes("prediction")) {
        action = "attack_path_prediction";
    }
    else if (lowerCommand.includes("custom workflow") || lowerCommand.includes("execute workflow")) {
        action = "custom_workflow_execution";
    }
    else if (lowerCommand.includes("metasploit") || lowerCommand.includes("msfconsole") || lowerCommand.includes("msf")) {
        action = "metasploit_integration";
    }
    else if (lowerCommand.includes("comprehensive") || lowerCommand.includes("full assessment") || lowerCommand.includes("complete test")) {
        action = "comprehensive_assessment";
    }
    else if (lowerCommand.includes("ai enhanced") || lowerCommand.includes("ai testing") || lowerCommand.includes("intelligent")) {
        action = "ai_enhanced_testing";
    }
    else if (lowerCommand.includes("report") || lowerCommand.includes("generate report")) {
        action = "report_generation";
    }
    else if (lowerCommand.includes("ethical") || lowerCommand.includes("guidelines") || lowerCommand.includes("responsible")) {
        action = "ethical_guidelines_check";
    }
    // Target type detection
    if (lowerCommand.includes("web app") || lowerCommand.includes("website") || lowerCommand.includes("web application")) {
        target_type = "web_application";
    }
    else if (lowerCommand.includes("network") || lowerCommand.includes("server") || lowerCommand.includes("host")) {
        target_type = "network";
    }
    else if (lowerCommand.includes("mobile") || lowerCommand.includes("android") || lowerCommand.includes("ios") || lowerCommand.includes("app")) {
        target_type = "mobile";
    }
    else if (lowerCommand.includes("cloud") || lowerCommand.includes("aws") || lowerCommand.includes("azure")) {
        target_type = "cloud";
    }
    else if (lowerCommand.includes("api") || lowerCommand.includes("rest api") || lowerCommand.includes("web api")) {
        target_type = "api";
    }
    // Reconnaissance type
    if (lowerCommand.includes("passive") || lowerCommand.includes("stealth")) {
        reconnaissance_type = "passive";
        stealth_mode = true;
    }
    else if (lowerCommand.includes("active") || lowerCommand.includes("aggressive")) {
        reconnaissance_type = "active";
    }
    else if (lowerCommand.includes("comprehensive") || lowerCommand.includes("thorough")) {
        reconnaissance_type = "comprehensive";
    }
    // Vulnerability type
    if (lowerCommand.includes("sql injection") || lowerCommand.includes("sqli")) {
        vulnerability_type = "sql_injection";
    }
    else if (lowerCommand.includes("xss") || lowerCommand.includes("cross-site scripting")) {
        vulnerability_type = "xss";
    }
    else if (lowerCommand.includes("csrf") || lowerCommand.includes("cross-site request forgery")) {
        vulnerability_type = "csrf";
    }
    else if (lowerCommand.includes("rce") || lowerCommand.includes("remote code execution")) {
        vulnerability_type = "rce";
    }
    else if (lowerCommand.includes("lfi") || lowerCommand.includes("local file inclusion")) {
        vulnerability_type = "lfi";
    }
    else if (lowerCommand.includes("rfi") || lowerCommand.includes("remote file inclusion")) {
        vulnerability_type = "rfi";
    }
    // Exploit framework
    if (lowerCommand.includes("metasploit") || lowerCommand.includes("msf")) {
        exploit_framework = "metasploit";
    }
    else if (lowerCommand.includes("custom") || lowerCommand.includes("manual")) {
        exploit_framework = "custom";
    }
    else if (lowerCommand.includes("burp") || lowerCommand.includes("burp suite")) {
        exploit_framework = "burp_suite";
    }
    // Attack vector
    if (lowerCommand.includes("web") || lowerCommand.includes("http")) {
        attack_vector = "web_application";
    }
    else if (lowerCommand.includes("network") || lowerCommand.includes("tcp") || lowerCommand.includes("udp")) {
        attack_vector = "network";
    }
    else if (lowerCommand.includes("social") || lowerCommand.includes("phishing")) {
        attack_vector = "social_engineering";
    }
    else if (lowerCommand.includes("physical") || lowerCommand.includes("hardware")) {
        attack_vector = "physical";
    }
    // Payload type
    if (lowerCommand.includes("reverse shell") || lowerCommand.includes("reverse_shell")) {
        payload_type = "reverse_shell";
    }
    else if (lowerCommand.includes("bind shell") || lowerCommand.includes("bind_shell")) {
        payload_type = "bind_shell";
    }
    else if (lowerCommand.includes("meterpreter")) {
        payload_type = "meterpreter";
    }
    else if (lowerCommand.includes("web shell") || lowerCommand.includes("webshell")) {
        payload_type = "web_shell";
    }
    // Report format
    if (lowerCommand.includes("pdf")) {
        report_format = "pdf";
    }
    else if (lowerCommand.includes("html")) {
        report_format = "html";
    }
    else if (lowerCommand.includes("json")) {
        report_format = "json";
    }
    else if (lowerCommand.includes("xml")) {
        report_format = "xml";
    }
    else if (lowerCommand.includes("csv")) {
        report_format = "csv";
    }
    // AI model
    if (lowerCommand.includes("gpt-4")) {
        ai_model = "gpt-4";
    }
    else if (lowerCommand.includes("gpt-3")) {
        ai_model = "gpt-3.5-turbo";
    }
    else if (lowerCommand.includes("claude")) {
        ai_model = "claude-3";
    }
    else if (lowerCommand.includes("gemini")) {
        ai_model = "gemini-pro";
    }
    // Automation level
    if (lowerCommand.includes("manual") || lowerCommand.includes("interactive")) {
        automation_level = "manual";
    }
    else if (lowerCommand.includes("semi") || lowerCommand.includes("partial")) {
        automation_level = "semi_automated";
    }
    else if (lowerCommand.includes("full") || lowerCommand.includes("automated") || lowerCommand.includes("automatic")) {
        automation_level = "fully_automated";
    }
    // AI features
    if (lowerCommand.includes("ai workflow") || lowerCommand.includes("workflow generation")) {
        ai_workflow_generation = true;
    }
    if (lowerCommand.includes("predict") || lowerCommand.includes("prediction") || lowerCommand.includes("attack path")) {
        attack_path_prediction = true;
    }
    // Integration type
    if (lowerCommand.includes("metasploit")) {
        integration_type = "metasploit";
    }
    else if (lowerCommand.includes("kali")) {
        integration_type = "kali";
    }
    else if (lowerCommand.includes("burp")) {
        integration_type = "burp_suite";
    }
    else if (lowerCommand.includes("nmap")) {
        integration_type = "nmap";
    }
    // Ethical guidelines
    if (lowerCommand.includes("ethical") || lowerCommand.includes("responsible") || lowerCommand.includes("authorized")) {
        ethical_guidelines = true;
    }
    // Safe mode
    if (lowerCommand.includes("safe mode") || lowerCommand.includes("simulation") || lowerCommand.includes("test") || lowerCommand.includes("demo")) {
        safe_mode = true;
    }
    return {
        action,
        target,
        target_type,
        reconnaissance_type,
        vulnerability_type,
        exploit_framework,
        attack_vector,
        payload_type,
        report_format,
        ai_model,
        automation_level,
        stealth_mode,
        ai_workflow_generation,
        attack_path_prediction,
        integration_type,
        ethical_guidelines,
        safe_mode
    };
}
