/**
 * PLY Export Utilities for RF Sense Point Cloud Data
 * Supports ASCII and binary PLY formats for cross-platform compatibility
 */

export interface Point3D {
  x: number;
  y: number;
  z: number;
  r?: number;
  g?: number;
  b?: number;
  intensity?: number;
}

export interface PointCloudData {
  points: Point3D[];
  metadata?: {
    source?: string;
    timestamp?: string;
    sessionId?: string;
    pipeline?: string;
    count?: number;
  };
}

/**
 * Convert point cloud data to ASCII PLY format
 * Compatible with CloudCompare, MeshLab, and other standard tools
 */
export function pointsToAsciiPLY(
  points: Array<[number, number, number]> | Point3D[] | PointCloudData,
  options: {
    includeColors?: boolean;
    includeIntensity?: boolean;
    metadata?: Record<string, string>;
  } = {}
): string {
  const { includeColors = false, includeIntensity = false, metadata = {} } = options;
  
  // Normalize input format
  let normalizedPoints: Point3D[];
  let cloudMetadata: Record<string, string> = {};
  
  if (Array.isArray(points)) {
    // Handle array of [x,y,z] tuples
    normalizedPoints = points.map((p, i) => {
      if (Array.isArray(p)) {
        return { x: p[0], y: p[1], z: p[2] };
      } else {
        return p;
      }
    });
  } else if (points.points) {
    // Handle PointCloudData object
    normalizedPoints = points.points;
    if (points.metadata) {
      cloudMetadata = {
        ...points.metadata,
        source: points.metadata.source || 'rf_sense',
        timestamp: points.metadata.timestamp || new Date().toISOString(),
        count: points.metadata.count?.toString() || normalizedPoints.length.toString()
      };
    }
  } else {
    throw new Error('Invalid point cloud data format');
  }
  
  const n = normalizedPoints.length;
  
  // Build PLY header
  let header = `ply
format ascii 1.0
comment Generated by RF Sense Point Cloud Viewer
comment Timestamp: ${cloudMetadata.timestamp || new Date().toISOString()}
comment Source: ${cloudMetadata.source || 'rf_sense'}
comment Session: ${cloudMetadata.sessionId || 'unknown'}
comment Pipeline: ${cloudMetadata.pipeline || 'unknown'}
comment Point Count: ${n}`;
  
  // Add custom metadata comments
  Object.entries({ ...cloudMetadata, ...metadata }).forEach(([key, value]) => {
    if (!['timestamp', 'source', 'sessionId', 'pipeline', 'count'].includes(key)) {
      header += `\ncomment ${key}: ${value}`;
    }
  });
  
  // Define vertex properties
  header += `\nelement vertex ${n}
property float x
property float y
property float z`;
  
  if (includeColors) {
    header += `\nproperty uchar red
property uchar green
property uchar blue`;
  }
  
  if (includeIntensity) {
    header += `\nproperty float intensity`;
  }
  
  header += `\nend_header\n`;
  
  // Generate vertex data
  const vertexData = normalizedPoints.map(point => {
    let line = `${point.x} ${point.y} ${point.z}`;
    
    if (includeColors) {
      const r = Math.round((point.r || 1) * 255);
      const g = Math.round((point.g || 1) * 255);
      const b = Math.round((point.b || 1) * 255);
      line += ` ${r} ${g} ${b}`;
    }
    
    if (includeIntensity) {
      line += ` ${point.intensity || 1.0}`;
    }
    
    return line;
  });
  
  return header + vertexData.join('\n') + '\n';
}

/**
 * Convert point cloud data to binary PLY format (little-endian)
 * More compact than ASCII format
 */
export function pointsToBinaryPLY(
  points: Array<[number, number, number]> | Point3D[] | PointCloudData,
  options: {
    includeColors?: boolean;
    includeIntensity?: boolean;
    metadata?: Record<string, string>;
  } = {}
): ArrayBuffer {
  const { includeColors = false, includeIntensity = false, metadata = {} } = options;
  
  // Normalize input format (same as ASCII)
  let normalizedPoints: Point3D[];
  let cloudMetadata: Record<string, string> = {};
  
  if (Array.isArray(points)) {
    normalizedPoints = points.map((p, i) => {
      if (Array.isArray(p)) {
        return { x: p[0], y: p[1], z: p[2] };
      } else {
        return p;
      }
    });
  } else if (points.points) {
    normalizedPoints = points.points;
    if (points.metadata) {
      cloudMetadata = {
        ...points.metadata,
        source: points.metadata.source || 'rf_sense',
        timestamp: points.metadata.timestamp || new Date().toISOString(),
        count: points.metadata.count?.toString() || normalizedPoints.length.toString()
      };
    }
  } else {
    throw new Error('Invalid point cloud data format');
  }
  
  const n = normalizedPoints.length;
  const bytesPerVertex = 12 + (includeColors ? 3 : 0) + (includeIntensity ? 4 : 0);
  const headerSize = 200; // Approximate header size
  const totalSize = headerSize + (n * bytesPerVertex);
  
  const buffer = new ArrayBuffer(totalSize);
  const view = new DataView(buffer);
  const encoder = new TextEncoder();
  
  // Build PLY header
  let header = `ply
format binary_little_endian 1.0
comment Generated by RF Sense Point Cloud Viewer
comment Timestamp: ${cloudMetadata.timestamp || new Date().toISOString()}
comment Source: ${cloudMetadata.source || 'rf_sense'}
comment Session: ${cloudMetadata.sessionId || 'unknown'}
comment Pipeline: ${cloudMetadata.pipeline || 'unknown'}
comment Point Count: ${n}`;
  
  // Add custom metadata comments
  Object.entries({ ...cloudMetadata, ...metadata }).forEach(([key, value]) => {
    if (!['timestamp', 'source', 'sessionId', 'pipeline', 'count'].includes(key)) {
      header += `\ncomment ${key}: ${value}`;
    }
  });
  
  // Define vertex properties
  header += `\nelement vertex ${n}
property float x
property float y
property float z`;
  
  if (includeColors) {
    header += `\nproperty uchar red
property uchar green
property uchar blue`;
  }
  
  if (includeIntensity) {
    header += `\nproperty float intensity`;
  }
  
  header += `\nend_header\n`;
  
  // Write header
  const headerBytes = encoder.encode(header);
  for (let i = 0; i < headerBytes.length; i++) {
    view.setUint8(i, headerBytes[i]);
  }
  
  // Write vertex data
  let offset = headerBytes.length;
  normalizedPoints.forEach(point => {
    // Write x, y, z as float32 (little-endian)
    view.setFloat32(offset, point.x, true); offset += 4;
    view.setFloat32(offset, point.y, true); offset += 4;
    view.setFloat32(offset, point.z, true); offset += 4;
    
    if (includeColors) {
      const r = Math.round((point.r || 1) * 255);
      const g = Math.round((point.g || 1) * 255);
      const b = Math.round((point.b || 1) * 255);
      view.setUint8(offset, r); offset += 1;
      view.setUint8(offset, g); offset += 1;
      view.setUint8(offset, b); offset += 1;
    }
    
    if (includeIntensity) {
      view.setFloat32(offset, point.intensity || 1.0, true); offset += 4;
    }
  });
  
  return buffer.slice(0, offset);
}

/**
 * Convert point cloud data to JSON format
 * Includes metadata and supports both array and object formats
 */
export function pointsToJSON(
  points: Array<[number, number, number]> | Point3D[] | PointCloudData,
  options: {
    format?: 'array' | 'object';
    includeMetadata?: boolean;
    metadata?: Record<string, string>;
  } = {}
): string {
  const { format = 'object', includeMetadata = true, metadata = {} } = options;
  
  // Normalize input format
  let normalizedPoints: Point3D[];
  let cloudMetadata: Record<string, string> = {};
  
  if (Array.isArray(points)) {
    normalizedPoints = points.map((p, i) => {
      if (Array.isArray(p)) {
        return { x: p[0], y: p[1], z: p[2] };
      } else {
        return p;
      }
    });
  } else if (points.points) {
    normalizedPoints = points.points;
    if (points.metadata) {
      cloudMetadata = {
        ...points.metadata,
        source: points.metadata.source || 'rf_sense',
        timestamp: points.metadata.timestamp || new Date().toISOString(),
        count: points.metadata.count?.toString() || normalizedPoints.length.toString()
      };
    }
  } else {
    throw new Error('Invalid point cloud data format');
  }
  
  if (format === 'array') {
    // Simple array format: [[x,y,z], ...]
    const arrayPoints = normalizedPoints.map(p => [p.x, p.y, p.z]);
    
    if (includeMetadata) {
      return JSON.stringify({
        points: arrayPoints,
        metadata: {
          ...cloudMetadata,
          ...metadata,
          format: 'array',
          count: normalizedPoints.length
        }
      }, null, 2);
    } else {
      return JSON.stringify(arrayPoints, null, 2);
    }
  } else {
    // Object format with full point data
    const result: any = {
      points: normalizedPoints,
      metadata: {
        ...cloudMetadata,
        ...metadata,
        format: 'object',
        count: normalizedPoints.length
      }
    };
    
    return JSON.stringify(result, null, 2);
  }
}

/**
 * Utility function to save point cloud data to file
 * Works in Node.js environments
 */
export async function savePointCloud(
  points: Array<[number, number, number]> | Point3D[] | PointCloudData,
  filePath: string,
  options: {
    format?: 'ply' | 'json' | 'binary_ply';
    includeColors?: boolean;
    includeIntensity?: boolean;
    metadata?: Record<string, string>;
  } = {}
): Promise<void> {
  const fs = await import('fs');
  const path = await import('path');
  
  const { format = 'ply', ...plyOptions } = options;
  
  // Ensure directory exists
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  
  let content: string | ArrayBuffer;
  
  switch (format) {
    case 'ply':
      content = pointsToAsciiPLY(points, plyOptions);
      fs.writeFileSync(filePath, content as string, 'utf8');
      break;
      
    case 'binary_ply':
      content = pointsToBinaryPLY(points, plyOptions);
      fs.writeFileSync(filePath, Buffer.from(content));
      break;
      
    case 'json':
      content = pointsToJSON(points, plyOptions);
      fs.writeFileSync(filePath, content as string, 'utf8');
      break;
      
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}

/**
 * Color mapping utilities for point clouds
 */
export function mapIntensityToColor(
  points: Point3D[],
  colorMap: 'viridis' | 'plasma' | 'inferno' | 'magma' | 'jet' = 'viridis'
): Point3D[] {
  const intensities = points.map(p => p.intensity || 0);
  const minIntensity = Math.min(...intensities);
  const maxIntensity = Math.max(...intensities);
  const range = maxIntensity - minIntensity || 1;
  
  return points.map(point => {
    const normalizedIntensity = (point.intensity || 0 - minIntensity) / range;
    const color = getColorFromMap(normalizedIntensity, colorMap);
    
    return {
      ...point,
      r: color.r,
      g: color.g,
      b: color.b
    };
  });
}

function getColorFromMap(t: number, map: string): { r: number; g: number; b: number } {
  // Simple color mapping functions
  // In a real implementation, you'd want more sophisticated color maps
  switch (map) {
    case 'viridis':
      return {
        r: Math.max(0, Math.min(1, 0.267 + 0.004 * t)),
        g: Math.max(0, Math.min(1, 0.004 + 0.859 * t)),
        b: Math.max(0, Math.min(1, 0.329 + 0.671 * t))
      };
    case 'plasma':
      return {
        r: Math.max(0, Math.min(1, 0.941 + 0.059 * t)),
        g: Math.max(0, Math.min(1, 0.000 + 0.000 * t)),
        b: Math.max(0, Math.min(1, 0.000 + 0.000 * t))
      };
    case 'jet':
      return {
        r: Math.max(0, Math.min(1, 1.5 - 4 * Math.abs(t - 0.75))),
        g: Math.max(0, Math.min(1, 1.5 - 4 * Math.abs(t - 0.5))),
        b: Math.max(0, Math.min(1, 1.5 - 4 * Math.abs(t - 0.25)))
      };
    default:
      return { r: t, g: t, b: t };
  }
}
