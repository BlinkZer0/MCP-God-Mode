/**
 * Testing Manager
 * 
 * Manages the execution of PoC tests in controlled environments
 * with safety checks and audit logging.
 */

import { 
  TestingSession, 
  TestingResult, 
  TestingEnvironment,
  ZeroDayVulnerability,
  LegalAcknowledgment 
} from '../schema/types.js';
import { spawn, ChildProcess } from 'child_process';
import { promises as fs } from 'fs';
import { join } from 'path';

export class TestingManager {
  private activeSessions: Map<string, TestingSession>;
  private environments: Map<string, TestingEnvironment>;
  private auditLog: any[];

  constructor() {
    this.activeSessions = new Map();
    this.environments = new Map();
    this.auditLog = [];
    this.initializeEnvironments();
  }

  /**
   * Start a new testing session
   */
  async startTestingSession(
    vulnerability: ZeroDayVulnerability,
    pocPath: string,
    environment: TestingEnvironment,
    legalAcknowledgment: LegalAcknowledgment
  ): Promise<TestingSession> {
    // Validate legal acknowledgment
    if (!this.validateLegalAcknowledgment(legalAcknowledgment)) {
      throw new Error('Legal acknowledgment required before testing');
    }

    // Create session
    const session: TestingSession = {
      id: this.generateSessionId(),
      startTime: new Date().toISOString(),
      vulnerability,
      environment,
      pocPath,
      status: 'Running',
      logs: []
    };

    this.activeSessions.set(session.id, session);

    // Log session start
    this.logAuditEvent('SESSION_START', {
      sessionId: session.id,
      cve: vulnerability.cve,
      environment: environment.name,
      pocPath
    });

    // Start testing in background
    this.executeTest(session).catch(error => {
      session.status = 'Failed';
      session.logs.push(`Error: ${error.message}`);
      this.logAuditEvent('SESSION_ERROR', {
        sessionId: session.id,
        error: error.message
      });
    });

    return session;
  }

  /**
   * Execute the PoC test
   */
  private async executeTest(session: TestingSession): Promise<void> {
    try {
      session.logs.push(`Starting test execution for ${session.vulnerability.cve}`);
      
      // Set up environment variables
      const env = {
        ...process.env,
        AUTHORIZED_TESTING: 'true',
        TARGET_HOST: session.environment.setupInstructions[0] || 'localhost',
        SESSION_ID: session.id,
        CVE_ID: session.vulnerability.cve
      };

      // Execute the PoC
      const result = await this.executePoC(session.pocPath, env);
      
      // Process results
      session.endTime = new Date().toISOString();
      session.status = result.status === 'Success' ? 'Completed' : 
                      result.status === 'Failed' ? 'Failed' : 
                      result.status === 'Partial' ? 'Completed' : 'Failed';
      session.results = result;
      
      // Log completion
      this.logAuditEvent('SESSION_COMPLETE', {
        sessionId: session.id,
        status: result.status,
        executionTime: result.executionTime
      });

    } catch (error) {
      session.status = 'Failed';
      session.logs.push(`Execution failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Execute PoC script
   */
  private async executePoC(pocPath: string, env: Record<string, string>): Promise<TestingResult> {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      let output = '';
      let errors: string[] = [];
      let warnings: string[] = [];

      // Determine execution command based on file extension
      const extension = pocPath.split('.').pop()?.toLowerCase();
      let command: string;
      let args: string[];

      switch (extension) {
        case 'py':
          command = 'python3';
          args = [pocPath];
          break;
        case 'js':
          command = 'node';
          args = [pocPath];
          break;
        case 'ps1':
          command = 'powershell';
          args = ['-ExecutionPolicy', 'Bypass', '-File', pocPath];
          break;
        case 'sh':
          command = 'bash';
          args = [pocPath];
          break;
        default:
          reject(new Error(`Unsupported file type: ${extension}`));
          return;
      }

      const process: ChildProcess = spawn(command, args, {
        env,
        stdio: ['pipe', 'pipe', 'pipe']
      });

      // Capture output
      process.stdout?.on('data', (data) => {
        output += data.toString();
      });

      process.stderr?.on('data', (data) => {
        const errorText = data.toString();
        errors.push(errorText);
        output += errorText;
      });

      // Handle process completion
      process.on('close', (code) => {
        const executionTime = `${Date.now() - startTime}ms`;
        
        const result: TestingResult = {
          vulnerability: this.getVulnerabilityFromSession(pocPath),
          pocPath,
          executionTime,
          status: code === 0 ? 'Success' : 'Failed',
          output,
          errors: errors.length > 0 ? errors : undefined,
          warnings: warnings.length > 0 ? warnings : undefined,
          recommendations: this.generateRecommendations(code, output, errors)
        };

        resolve(result);
      });

      // Handle process errors
      process.on('error', (error) => {
        reject(new Error(`Failed to execute PoC: ${error.message}`));
      });

      // Set timeout
      setTimeout(() => {
        process.kill();
        reject(new Error('PoC execution timeout'));
      }, 300000); // 5 minutes timeout
    });
  }

  /**
   * Get vulnerability from session (helper method)
   */
  private getVulnerabilityFromSession(pocPath: string): ZeroDayVulnerability {
    // This would normally be retrieved from the session
    // For now, return a minimal vulnerability object
    return {
      id: 'temp',
      cve: 'CVE-TEMP',
      title: 'Temporary',
      description: 'Temporary vulnerability for testing',
      affectedSoftware: [],
      cvssScore: 0,
      cvssVector: '',
      severity: 'Low',
      exploitationStatus: 'Unknown',
      disclosureDate: new Date().toISOString(),
      sources: [],
      attackVector: 'Network',
      attackComplexity: 'Low',
      privilegesRequired: 'None',
      userInteraction: 'None',
      scope: 'Unchanged',
      confidentialityImpact: 'None',
      integrityImpact: 'None',
      availabilityImpact: 'None',
      tags: [],
      references: [],
      pocAvailable: false
    };
  }

  /**
   * Generate recommendations based on test results
   */
  private generateRecommendations(exitCode: number, output: string, errors: string[]): string[] {
    const recommendations: string[] = [];

    if (exitCode === 0) {
      recommendations.push('‚úÖ Test completed successfully');
      recommendations.push('üìã Review the output for any security findings');
      recommendations.push('üîç Consider manual verification of results');
    } else {
      recommendations.push('‚ùå Test failed - check error messages');
      recommendations.push('üîß Verify target system is accessible and configured correctly');
      recommendations.push('üìù Review prerequisites and dependencies');
    }

    if (output.includes('vulnerability detected') || output.includes('exploit successful')) {
      recommendations.push('üö® Potential vulnerability confirmed - immediate patching recommended');
      recommendations.push('üõ°Ô∏è Implement additional security controls');
      recommendations.push('üìä Document findings for security team');
    }

    if (errors.some(error => error.includes('permission') || error.includes('access'))) {
      recommendations.push('üîê Check permissions and access controls');
      recommendations.push('üë§ Verify user has appropriate privileges for testing');
    }

    return recommendations;
  }

  /**
   * Validate legal acknowledgment
   */
  private validateLegalAcknowledgment(acknowledgment: LegalAcknowledgment): boolean {
    if (!acknowledgment.required) {
      return true;
    }

    return acknowledgment.acknowledged === true && 
           !!acknowledgment.timestamp && 
           !!acknowledgment.userSignature;
  }

  /**
   * Generate unique session ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Log audit event
   */
  private logAuditEvent(action: string, details: any): void {
    const logEntry = {
      id: `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      action,
      details,
      riskLevel: this.assessRiskLevel(action, details),
      legalCompliant: true
    };

    this.auditLog.push(logEntry);
    
    // In a real implementation, this would be persisted to a secure log store
    console.log(`[AUDIT] ${action}:`, details);
  }

  /**
   * Assess risk level for audit event
   */
  private assessRiskLevel(action: string, details: any): 'Low' | 'Medium' | 'High' | 'Critical' {
    const highRiskActions = ['SESSION_START', 'POC_EXECUTION', 'VULNERABILITY_DETECTED'];
    const criticalRiskActions = ['UNAUTHORIZED_ACCESS', 'LEGAL_VIOLATION'];

    if (criticalRiskActions.includes(action)) {
      return 'Critical';
    } else if (highRiskActions.includes(action)) {
      return 'High';
    } else if (action.includes('ERROR') || action.includes('FAILED')) {
      return 'Medium';
    } else {
      return 'Low';
    }
  }

  /**
   * Get active session
   */
  getSession(sessionId: string): TestingSession | null {
    return this.activeSessions.get(sessionId) || null;
  }

  /**
   * Get all active sessions
   */
  getActiveSessions(): TestingSession[] {
    return Array.from(this.activeSessions.values());
  }

  /**
   * Cancel a testing session
   */
  async cancelSession(sessionId: string): Promise<boolean> {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      return false;
    }

    session.status = 'Cancelled';
    session.endTime = new Date().toISOString();

    this.logAuditEvent('SESSION_CANCELLED', {
      sessionId,
      reason: 'User requested cancellation'
    });

    return true;
  }

  /**
   * Get audit log
   */
  getAuditLog(): any[] {
    return [...this.auditLog];
  }

  /**
   * Initialize testing environments
   */
  private initializeEnvironments(): void {
    // Local testing environment
    this.environments.set('local', {
      id: 'local',
      name: 'Local Testing Environment',
      type: 'Local',
      description: 'Local machine for safe testing',
      setupInstructions: [
        'localhost',
        'Ensure no production services are running',
        'Use isolated network if possible'
      ],
      safetyWarnings: [
        'Only test on systems you own',
        'Ensure no sensitive data is present',
        'Use virtual machines when possible'
      ],
      cleanupInstructions: [
        'Stop any test services',
        'Remove temporary files',
        'Restart system if necessary'
      ]
    });

    // Isolated testing environment
    this.environments.set('isolated', {
      id: 'isolated',
      name: 'Isolated Testing Environment',
      type: 'Isolated',
      description: 'Network-isolated environment for safe testing',
      setupInstructions: [
        'Set up isolated network segment',
        'Configure test targets',
        'Ensure no internet connectivity'
      ],
      safetyWarnings: [
        'Verify network isolation',
        'Monitor for unexpected network activity',
        'Have rollback procedures ready'
      ],
      cleanupInstructions: [
        'Power down test systems',
        'Restore network connectivity',
        'Document any changes made'
      ]
    });

    // Sandbox environment
    this.environments.set('sandbox', {
      id: 'sandbox',
      name: 'Sandbox Environment',
      type: 'Sandbox',
      description: 'Contained sandbox for testing',
      setupInstructions: [
        'Deploy sandbox container',
        'Configure test environment',
        'Set up monitoring'
      ],
      safetyWarnings: [
        'Verify sandbox isolation',
        'Monitor resource usage',
        'Have escape procedures ready'
      ],
      cleanupInstructions: [
        'Destroy sandbox container',
        'Clean up resources',
        'Review logs for anomalies'
      ]
    });
  }

  /**
   * Get available environments
   */
  getAvailableEnvironments(): TestingEnvironment[] {
    return Array.from(this.environments.values());
  }

  /**
   * Get environment by ID
   */
  getEnvironment(environmentId: string): TestingEnvironment | null {
    return this.environments.get(environmentId) || null;
  }
}
