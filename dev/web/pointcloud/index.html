<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Point Cloud Viewer - RF Sense</title>
<link rel="manifest" href="./manifest.webmanifest"/>
<style>
  html,body{margin:0;height:100%;background:#111;color:#ddd;font:14px system-ui}
  #bar{position:fixed;top:0;left:0;right:0;padding:10px 12px;background:#1b1b1b;z-index:10;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  #file{display:inline-block}
  #btnLive{padding:6px 10px;background:#2a2a2a;border:1px solid #444;border-radius:8px;color:#ddd;cursor:pointer}
  #btnLive:hover{background:#3a3a3a}
  #btnLive:disabled{opacity:0.5;cursor:not-allowed}
  #status{padding:4px 8px;background:#333;border-radius:4px;font-size:12px}
  #canvas{position:absolute;top:48px;left:0;right:0;bottom:0}
  #info{position:fixed;bottom:10px;left:10px;background:rgba(0,0,0,0.7);padding:8px;border-radius:4px;font-size:12px}
  .loading{opacity:0.6}
</style>
</head>
<body>
<div id="bar">
  <label>Open .ply/.json: <input id="file" type="file" accept=".ply,.json"/></label>
  <button id="btnLive">Connect Live</button>
  <div id="status">Ready</div>
</div>
<canvas id="canvas"></canvas>
<div id="info">
  <div>Points: <span id="pointCount">0</span></div>
  <div>Controls: Mouse/Touch to rotate, scroll to zoom</div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { PLYLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/PLYLoader.js";

const canvas = document.getElementById("canvas");
const status = document.getElementById("status");
const pointCount = document.getElementById("pointCount");
const btnLive = document.getElementById("btnLive");

const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(60, 2, 0.01, 10000);
camera.position.set(0,0,50);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

const keyLight = new THREE.DirectionalLight(0xffffff, 1); 
keyLight.position.set(1,1,1);
scene.add(keyLight, new THREE.AmbientLight(0xffffff, 0.2));

let currentPoints = null;

function setStatus(msg, loading = false) {
  status.textContent = msg;
  status.className = loading ? "loading" : "";
}

function updatePointCount(count) {
  pointCount.textContent = count.toLocaleString();
}

function resize(){
  const w = window.innerWidth, h = window.innerHeight - 48;
  renderer.setSize(w, h, false);
  camera.aspect = w/h; 
  camera.updateProjectionMatrix();
}
window.addEventListener("resize", resize); 
resize();

function fit(geom){
  geom.computeBoundingBox();
  const bb = geom.boundingBox;
  const c = bb.getCenter(new THREE.Vector3());
  const size = bb.getSize(new THREE.Vector3()).length() || 1;
  scene.position.set(-c.x,-c.y,-c.z);
  camera.position.set(0,0,size*1.5);
  controls.update();
}

function setPointsFromPositions(positions, colors = null){
  const geom = new THREE.BufferGeometry();
  geom.setAttribute("position", new THREE.BufferAttribute(positions,3));
  
  if (colors) {
    geom.setAttribute("color", new THREE.BufferAttribute(colors,3));
  }
  
  const mat = new THREE.PointsMaterial({ 
    size: 0.05,
    vertexColors: !!colors,
    sizeAttenuation: true
  });
  
  const pts = new THREE.Points(geom, mat);
  scene.clear(); 
  scene.add(pts, keyLight);
  fit(geom);
  
  updatePointCount(positions.length / 3);
  currentPoints = { positions, colors };
}

function loadPLY(buf){
  setStatus("Loading PLY...", true);
  try {
    const loader = new PLYLoader();
    const geom = loader.parse(buf);
    
    // Extract positions and colors if available
    const positions = geom.attributes.position.array;
    const colors = geom.attributes.color ? geom.attributes.color.array : null;
    
    const mat = new THREE.PointsMaterial({ 
      size: 0.05,
      vertexColors: !!colors,
      sizeAttenuation: true
    });
    
    const pts = new THREE.Points(geom, mat);
    scene.clear(); 
    scene.add(pts, keyLight);
    fit(geom);
    
    updatePointCount(positions.length / 3);
    currentPoints = { positions, colors };
    setStatus("PLY loaded");
  } catch (e) {
    setStatus("Error loading PLY: " + e.message);
  }
}

function loadJSON(text){
  setStatus("Loading JSON...", true);
  try {
    const data = JSON.parse(text);
    let arr;
    
    // Handle different JSON formats
    if (Array.isArray(data)) {
      // Direct array of points [[x,y,z], ...]
      arr = data;
    } else if (data.points && Array.isArray(data.points)) {
      // Object with points property
      arr = data.points;
    } else if (data.positions && Array.isArray(data.positions)) {
      // Object with positions property
      arr = data.positions;
    } else {
      throw new Error("Unsupported JSON format");
    }
    
    const positions = new Float32Array(arr.length * 3);
    let colors = null;
    
    // Check if we have color data
    if (arr[0] && arr[0].length >= 6) {
      colors = new Float32Array(arr.length * 3);
    }
    
    for (let i = 0; i < arr.length; i++) { 
      const p = arr[i];
      positions[3*i] = p[0]; 
      positions[3*i+1] = p[1]; 
      positions[3*i+2] = p[2];
      
      if (colors && p.length >= 6) {
        colors[3*i] = p[3] || 1;     // r
        colors[3*i+1] = p[4] || 1;   // g  
        colors[3*i+2] = p[5] || 1;   // b
      }
    }
    
    setPointsFromPositions(positions, colors);
    setStatus("JSON loaded");
  } catch (e) {
    setStatus("Error loading JSON: " + e.message);
  }
}

// File input handler
document.getElementById("file").addEventListener("change", async (e)=>{
  const f = e.target.files[0]; 
  if(!f) return;
  
  setStatus(`Loading ${f.name}...`, true);
  
  try {
    if (f.name.endsWith(".ply")) {
      loadPLY(await f.arrayBuffer());
    } else if (f.name.endsWith(".json")) {
      loadJSON(await f.text());
    } else {
      setStatus("Unsupported file format");
    }
  } catch (e) {
    setStatus("Error loading file: " + e.message);
  }
});

// Live mode: fetch JSON stream from MPC
document.getElementById("btnLive").addEventListener("click", async ()=>{
  btnLive.disabled = true;
  setStatus("Connecting to live feed...", true);
  
  try {
    const res = await fetch("/api/rf_sense/points");
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const data = await res.json();
    
    if (!data || !Array.isArray(data) || data.length === 0) {
      setStatus("No point data available");
      return;
    }
    
    // Convert to positions array
    const positions = new Float32Array(data.length * 3);
    for (let i = 0; i < data.length; i++) { 
      const p = data[i];
      positions[3*i] = p[0]; 
      positions[3*i+1] = p[1]; 
      positions[3*i+2] = p[2];
    }
    
    setPointsFromPositions(positions);
    setStatus("Live data loaded");
  } catch(e) { 
    setStatus("Live fetch failed: " + e.message);
  } finally {
    btnLive.disabled = false;
  }
});

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(console.error);
}

// Animation loop
function loop(){ 
  requestAnimationFrame(loop); 
  controls.update(); 
  renderer.render(scene,camera); 
}
loop();

// Handle URL parameters for direct loading
const urlParams = new URLSearchParams(window.location.search);
const src = urlParams.get('src');
if (src) {
  setStatus("Loading from URL...", true);
  fetch(src)
    .then(res => res.text())
    .then(loadJSON)
    .catch(e => setStatus("URL load failed: " + e.message));
}
</script>
</body>
</html>
