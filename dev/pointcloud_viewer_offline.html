<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RF Sense Point Cloud Viewer - Offline</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.8;
            font-size: 1.1em;
        }
        
        .controls {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        
        .file-input {
            margin-bottom: 15px;
        }
        
        .file-input input[type="file"] {
            background: rgba(255,255,255,0.2);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 20px;
            width: 100%;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        
        .file-input input[type="file"]:hover {
            border-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.3);
        }
        
        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            margin-right: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
        }
        
        .canvas-container {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        #pointCloudCanvas {
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: #000;
            max-width: 100%;
            height: auto;
        }
        
        .info-panel {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .info-item:last-child {
            border-bottom: none;
        }
        
        .info-label {
            font-weight: bold;
            opacity: 0.8;
        }
        
        .info-value {
            color: #74b9ff;
        }
        
        .status {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status.success {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
        }
        
        .status.error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            color: #e74c3c;
        }
        
        .status.info {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“¡ RF Sense Point Cloud Viewer</h1>
            <p>Offline 3D Point Cloud Visualization</p>
        </div>
        
        <div class="controls">
            <div class="file-input">
                <input type="file" id="fileInput" accept=".json" />
                <p>Select a JSON file containing point cloud data</p>
            </div>
            
            <button class="btn" onclick="generateSampleData()">Generate Sample Data</button>
            <button class="btn btn-secondary" onclick="resetView()">Reset View</button>
            <button class="btn btn-secondary" onclick="clearCanvas()">Clear Canvas</button>
            <button class="btn btn-secondary" onclick="downloadData()">Download Data</button>
        </div>
        
        <div id="status"></div>
        
        <div class="canvas-container">
            <canvas id="pointCloudCanvas" width="800" height="600"></canvas>
        </div>
        
        <div class="info-panel" id="infoPanel" style="display: none;">
            <h3>Point Cloud Information</h3>
            <div id="infoContent"></div>
        </div>
    </div>

    <script>
        let pointCloudData = null;
        let canvas, ctx;
        
        // Navigation variables
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let offsetX = 0;
        let offsetY = 0;
        let scale = 1;
        let minX, maxX, minY, maxY, minZ, maxZ;
        let baseScale = 1;
        let baseOffsetX = 0;
        let baseOffsetY = 0;
        
        // Initialize canvas
        window.onload = function() {
            canvas = document.getElementById('pointCloudCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = 800;
            canvas.height = 600;
            
            // Clear canvas
            clearCanvas();
            
            // Set up file input
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            
            // Set up mouse events for navigation
            setupMouseEvents();
        };
        
        function setupMouseEvents() {
            // Mouse down - start dragging
            canvas.addEventListener('mousedown', function(e) {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });
            
            // Mouse move - drag
            canvas.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    offsetX += deltaX;
                    offsetY += deltaY;
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    // Re-render with new offset
                    if (pointCloudData) {
                        renderPointCloud();
                    }
                }
            });
            
            // Mouse up - stop dragging
            canvas.addEventListener('mouseup', function() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            // Mouse leave - stop dragging
            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            // Mouse wheel - zoom
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const mouseX = e.clientX - canvas.offsetLeft;
                const mouseY = e.clientY - canvas.offsetTop;
                
                // Calculate zoom around mouse position
                const worldX = (mouseX - offsetX) / scale;
                const worldY = (mouseY - offsetY) / scale;
                
                scale *= zoomFactor;
                scale = Math.max(0.1, Math.min(10, scale)); // Limit zoom range
                
                // Adjust offset to zoom around mouse position
                offsetX = mouseX - worldX * scale;
                offsetY = mouseY - worldY * scale;
                
                // Re-render with new scale
                if (pointCloudData) {
                    renderPointCloud();
                }
            });
            
            // Set initial cursor
            canvas.style.cursor = 'grab';
        }
        
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    loadPointCloudData(data);
                } catch (error) {
                    showStatus('Error parsing JSON file: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        function loadPointCloudData(data) {
            try {
                // Handle different data formats
                if (data.points && Array.isArray(data.points)) {
                    pointCloudData = data.points;
                } else if (Array.isArray(data)) {
                    pointCloudData = data;
                } else if (data.point_cloud && data.point_cloud.points) {
                    pointCloudData = data.point_cloud.points;
                } else if (data.sessionId && data.deviceConfig) {
                    // This is an RF sense export file - generate sample data based on the session
                    showStatus('RF Sense session file detected. Generating sample data based on session parameters...', 'info');
                    generateRfSenseData(data);
                    return;
                } else {
                    throw new Error('Invalid point cloud data format. Expected: points array, or RF sense session data');
                }
                
                renderPointCloud();
                updateInfoPanel(data);
                showStatus(`Loaded ${pointCloudData.length} points successfully!`, 'success');
                
            } catch (error) {
                showStatus('Error loading point cloud data: ' + error.message, 'error');
            }
        }
        
        function generateRfSenseData(sessionData) {
            // Generate realistic point cloud data based on RF sense session parameters
            const numPoints = 30000; // Generate 30k points as requested
            const points = [];
            
            // Use session parameters to make data more realistic
            const frequency = sessionData.deviceConfig?.frequency || 77;
            const frameRate = sessionData.deviceConfig?.frameRate || 100;
            const duration = sessionData.duration || 10000; // ms
            const expectedFrames = Math.floor((duration / 1000) * frameRate);
            
            // Generate points in a realistic 3D space
            for (let i = 0; i < numPoints; i++) {
                // Create more realistic distribution
                const angle = (i / numPoints) * Math.PI * 2;
                const radius = Math.random() * 8 + 1; // 1-9 meter radius
                const height = Math.random() * 3; // 0-3 meter height
                
                const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 2;
                const y = Math.sin(angle) * radius + (Math.random() - 0.5) * 2;
                const z = height + Math.random() * 0.5;
                
                points.push([x, y, z]);
            }
            
            const data = {
                points: points,
                source: 'RF Sense mmWave (Generated)',
                timestamp: new Date(sessionData.startTime || Date.now()).toISOString(),
                metadata: {
                    sessionId: sessionData.sessionId,
                    originalSession: true,
                    generated: true,
                    count: numPoints,
                    deviceConfig: sessionData.deviceConfig,
                    duration: sessionData.duration,
                    annotation: sessionData.annotation
                }
            };
            
            // Set the point cloud data directly and render
            pointCloudData = points;
            renderPointCloud();
            updateInfoPanel(data);
            showStatus(`Generated ${numPoints} points from RF Sense session data!`, 'success');
        }
        
        function renderPointCloud() {
            if (!pointCloudData || !Array.isArray(pointCloudData) || pointCloudData.length === 0) {
                showStatus('No point cloud data to render', 'error');
                return;
            }
            
            clearCanvas();
            
            // Calculate bounds (only on first render or when data changes)
            if (minX === undefined) {
                minX = Infinity, maxX = -Infinity;
                minY = Infinity, maxY = -Infinity;
                minZ = Infinity, maxZ = -Infinity;
                
                pointCloudData.forEach(point => {
                    if (!point) return; // Skip null/undefined points
                    
                    let x, y, z;
                    if (Array.isArray(point) && point.length >= 3) {
                        [x, y, z] = point;
                    } else if (point.x !== undefined && point.y !== undefined && point.z !== undefined) {
                        x = point.x;
                        y = point.y;
                        z = point.z;
                    } else {
                        return; // Skip invalid points
                    }
                    
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                });
                
                // Calculate initial scale and offset
                const rangeX = maxX - minX;
                const rangeY = maxY - minY;
                const rangeZ = maxZ - minZ;
                
                baseScale = Math.min(canvas.width / rangeX, canvas.height / rangeY) * 0.8;
                baseOffsetX = (canvas.width - rangeX * baseScale) / 2 - minX * baseScale;
                baseOffsetY = (canvas.height - rangeY * baseScale) / 2 - minY * baseScale;
                
                // Initialize navigation variables
                scale = baseScale;
                offsetX = baseOffsetX;
                offsetY = baseOffsetY;
            }
            
            const rangeZ = maxZ - minZ;
            
            // Render points
            pointCloudData.forEach((point, index) => {
                if (!point) return; // Skip null/undefined points
                
                let x, y, z;
                if (Array.isArray(point) && point.length >= 3) {
                    [x, y, z] = point;
                } else if (point.x !== undefined && point.y !== undefined && point.z !== undefined) {
                    x = point.x;
                    y = point.y;
                    z = point.z;
                } else {
                    return; // Skip invalid points
                }
                
                // Convert 3D to 2D projection using navigation variables
                const screenX = x * scale + offsetX;
                const screenY = y * scale + offsetY;
                
                // Skip points outside canvas for performance
                if (screenX < -10 || screenX > canvas.width + 10 || 
                    screenY < -10 || screenY > canvas.height + 10) {
                    return;
                }
                
                // Color based on Z height
                const normalizedZ = (z - minZ) / rangeZ;
                const hue = normalizedZ * 240; // Blue to red
                const alpha = 0.7 + normalizedZ * 0.3;
                
                // Adjust point size based on zoom level
                const pointSize = Math.max(1, Math.min(5, 2 * scale / baseScale));
                
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, pointSize, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Add coordinate axes
            drawAxes(minX, maxX, minY, maxY, scale, offsetX, offsetY);
            
            showStatus(`Rendered ${pointCloudData.length} points`, 'success');
        }
        
        function drawAxes(minX, maxX, minY, maxY, scale, offsetX, offsetY) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = Math.max(1, 2 * scale / baseScale);
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(minX * scale + offsetX, minY * scale + offsetY);
            ctx.lineTo(maxX * scale + offsetX, minY * scale + offsetY);
            ctx.stroke();
            
            // Y axis
            ctx.beginPath();
            ctx.moveTo(minX * scale + offsetX, minY * scale + offsetY);
            ctx.lineTo(minX * scale + offsetX, maxY * scale + offsetY);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = 'white';
            ctx.font = `${Math.max(10, 12 * scale / baseScale)}px Arial`;
            ctx.fillText('X', maxX * scale + offsetX + 5, minY * scale + offsetY);
            ctx.fillText('Y', minX * scale + offsetX, maxY * scale + offsetY - 5);
        }
        
        function updateInfoPanel(data) {
            const infoPanel = document.getElementById('infoPanel');
            const infoContent = document.getElementById('infoContent');
            
            if (!pointCloudData || !Array.isArray(pointCloudData)) return;
            
            // Calculate statistics
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            pointCloudData.forEach(point => {
                if (!point) return; // Skip null/undefined points
                
                let x, y, z;
                if (Array.isArray(point) && point.length >= 3) {
                    [x, y, z] = point;
                } else if (point.x !== undefined && point.y !== undefined && point.z !== undefined) {
                    x = point.x;
                    y = point.y;
                    z = point.z;
                } else {
                    return; // Skip invalid points
                }
                
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            });
            
            const info = `
                <div class="info-item">
                    <span class="info-label">Total Points:</span>
                    <span class="info-value">${pointCloudData.length.toLocaleString()}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">X Range:</span>
                    <span class="info-value">${minX.toFixed(2)} to ${maxX.toFixed(2)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Y Range:</span>
                    <span class="info-value">${minY.toFixed(2)} to ${maxY.toFixed(2)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Z Range:</span>
                    <span class="info-value">${minZ.toFixed(2)} to ${maxZ.toFixed(2)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Source:</span>
                    <span class="info-value">${data.source || 'RF Sense mmWave'}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Timestamp:</span>
                    <span class="info-value">${data.timestamp || new Date().toISOString()}</span>
                </div>
            `;
            
            infoContent.innerHTML = info;
            infoPanel.style.display = 'block';
        }
        
        function generateSampleData() {
            const sampleData = [];
            const numPoints = 1000;
            
            for (let i = 0; i < numPoints; i++) {
                // Generate points in a 3D space
                const x = (Math.random() - 0.5) * 10;
                const y = (Math.random() - 0.5) * 10;
                const z = Math.random() * 3;
                sampleData.push([x, y, z]);
            }
            
            const data = {
                points: sampleData,
                source: 'Sample Data Generator',
                timestamp: new Date().toISOString(),
                metadata: {
                    generated: true,
                    count: numPoints
                }
            };
            
            loadPointCloudData(data);
            showStatus('Generated sample point cloud data', 'success');
        }
        
        function clearCanvas() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add title
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('RF Sense Point Cloud Viewer', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '16px Arial';
            ctx.fillText('Load a JSON file or generate sample data', canvas.width / 2, canvas.height / 2 + 10);
            ctx.font = '14px Arial';
            ctx.fillText('Click and drag to pan â€¢ Mouse wheel to zoom', canvas.width / 2, canvas.height / 2 + 35);
            
            document.getElementById('infoPanel').style.display = 'none';
            pointCloudData = null;
            
            // Reset navigation variables
            resetNavigation();
        }
        
        function resetNavigation() {
            isDragging = false;
            offsetX = 0;
            offsetY = 0;
            scale = 1;
            minX = maxX = minY = maxY = minZ = maxZ = undefined;
            baseScale = 1;
            baseOffsetX = 0;
            baseOffsetY = 0;
        }
        
        function resetView() {
            if (!pointCloudData) {
                showStatus('No data to reset view for', 'error');
                return;
            }
            
            // Reset navigation variables
            isDragging = false;
            offsetX = 0;
            offsetY = 0;
            scale = 1;
            minX = maxX = minY = maxY = minZ = maxZ = undefined;
            baseScale = 1;
            baseOffsetX = 0;
            baseOffsetY = 0;
            
            // Re-render with reset view
            renderPointCloud();
            showStatus('View reset to original position and zoom', 'success');
        }
        
        function downloadData() {
            if (!pointCloudData) {
                showStatus('No data to download', 'error');
                return;
            }
            
            const data = {
                points: pointCloudData,
                source: 'RF Sense Point Cloud Viewer',
                timestamp: new Date().toISOString(),
                metadata: {
                    exported: true,
                    count: pointCloudData.length
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pointcloud_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus('Data downloaded successfully', 'success');
        }
    </script>
</body>
</html>
